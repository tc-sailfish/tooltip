{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///tooltip.js","webpack:///webpack/bootstrap 4946f3fa12d5e3a2f8f7","webpack:///./tooltip.js","webpack:///Tooltip.vue","webpack:///./src/bem.js","webpack:///./~/popper.js/dist/popper.es5.js","webpack:///./src/Tooltip.vue?4d58","webpack:///./~/vue-loader/lib/component-normalizer.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_0_src_Tooltip_vue__","__WEBPACK_IMPORTED_MODULE_0_src_Tooltip_vue___default","window","Vue","component","a","_toConsumableArray","arr","Array","isArray","arr2","length","from","__WEBPACK_IMPORTED_MODULE_0_popper_js__","__WEBPACK_IMPORTED_MODULE_0_popper_js___default","__WEBPACK_IMPORTED_MODULE_1__bem_js__","prefix","props","placement","type","String","default","delay","Number","content","manual","Boolean","disabled","data","isShow","timeoutId","render","h","class","concat","cn","on","mouseenter","fn","show","mouseleave","hide","$slots","attrs","ref","directives","mounted","popper","$el","$refs","modifiers","arrow","element","methods","state","$options","block","update","clearTimeout","_this","setTimeout","prefixBem","bem","_ref","_ref2","global","getOffsetParent","offsetParent","nodeName","document","documentElement","getStyleComputedProperty","nodeType","css","getComputedStyle","getParentNode","parentNode","host","getScrollParent","indexOf","body","_getStyleComputedProp","overflow","overflowX","overflowY","test","isFixed","getPosition","getBordersSize","styles","axis","sideA","sideB","split","getBoundingClientRect","isIE10","navigator","appVersion","rect","err","result","left","top","right","bottom","width","height","_window$document$docu","scrollTop","scrollLeft","horizScrollbar","clientWidth","vertScrollbar","clientHeight","getScroll","side","arguments","undefined","upperSide","html","scrollingElement","includeScroll","subtract","modifier","getOffsetRectRelativeToCustomParent","parent","fixed","transformed","scrollParent","elementRect","parentRect","contains","borderTopWidth","borderLeftWidth","getWindowSizes","Math","max","scrollHeight","offsetHeight","scrollWidth","offsetWidth","getOffsetRect","_getWindowSizes","offsetLeft","offsetTop","getOffsetRectRelativeToViewport","relativeOffset","parentOffset","getTotalScroll","scroll","getBoundaries","padding","boundariesElement","boundaries","_getOffsetRectRelativ","boundariesNode","_height","_width","computeAutoPlacement","refRect","sides","computedPlacement","keys","sort","b","variation","microtaskDebounce","scheduled","elem","createElement","MutationObserver","observe","attributes","setAttribute","taskDebounce","timeoutDuration","find","check","filter","findIndex","prop","cur","match","obj","getClientRect","popperOffsets","_extends","getOuterSizes","x","parseFloat","marginTop","marginBottom","y","marginLeft","marginRight","getOppositePlacement","hash","replace","matched","getPopperOffsets","position","referenceOffsets","popperRect","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","getReferenceOffsets","reference","isParentFixed","isParentTransformed","getSupportedPropertyName","prefixes","upperProp","charAt","toUpperCase","slice","toCheck","style","isFunction","functionToCheck","getType","toString","isModifierEnabled","modifierName","some","enabled","isModifierRequired","requestingName","requestedName","requesting","order","isNumeric","isNaN","isFinite","isTransformed","removeEventListeners","removeEventListener","updateBound","scrollParents","forEach","target","scrollElement","eventsEnabled","runModifiers","ends","function","setAttributes","removeAttribute","setStyles","unit","attachToScrollParents","event","callback","isBody","addEventListener","passive","push","setupEventListeners","options","applyStyle","offsets","x-placement","round","prefixedProperty","gpuAcceleration","willChange","instance","arrowElement","applyStyleOnLoad","modifierOptions","console","warn","querySelector","isVertical","len","altSide","opSide","arrowElementSize","center","sideValue","min","getOppositeVariation","flip","flipped","originalPlacement","placementOpposite","flipOrder","behavior","step","index","refOffsets","floor","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariation","flipVariations","keepTogether","offset","map","useHeight","innerHeight","innerWidth","preventOverflow","priority","primary","escapeWithReference","secondary","shift","basePlacement","shiftvariation","shiftOffsets","start","end","bound","inner","subtractLength","nativeHints","isNative","hint","isBrowser","longerTimeoutBrowsers","userAgent","supportsNativeMutationObserver","debounce","classCallCheck","Constructor","TypeError","createClass","defineProperties","descriptor","writable","key","protoProps","staticProps","assign","source","Utils","onLoad","DEFAULTS","onCreate","onUpdate","Popper","scheduleUpdate","requestAnimationFrame","bind","Defaults","isDestroyed","isCreated","jquery","defaultConfig","enableEventListeners","disableEventListeners","removeOnDestroy","removeChild","cancelAnimationFrame","placements","Component","rawScriptExports","compiledTemplate","scopeId","cssModules","esModule","scriptExports","staticRenderFns","_scopeId","computed"],"mappings":"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","file":"tooltip.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Tooltip\"] = factory();\n\telse\n\t\troot[\"Tooltip\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Tooltip\"] = factory();\n\telse\n\t\troot[\"Tooltip\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_src_Tooltip_vue__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_src_Tooltip_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_src_Tooltip_vue__);\n\n\nif (window.Vue) {\n    window.Vue.component(__WEBPACK_IMPORTED_MODULE_0_src_Tooltip_vue___default.a.name, __WEBPACK_IMPORTED_MODULE_0_src_Tooltip_vue___default.a);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = __WEBPACK_IMPORTED_MODULE_0_src_Tooltip_vue___default.a;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRvb2x0aXAuanMiXSwibmFtZXMiOlsiVG9vbHRpcCIsIndpbmRvdyIsIlZ1ZSIsImNvbXBvbmVudCIsIm5hbWUiXSwibWFwcGluZ3MiOiJBQUFBLE9BQU9BLE9BQVAsTUFBb0IsaUJBQXBCOztBQUVBLElBQUdDLE9BQU9DLEdBQVYsRUFBZTtBQUNYRCxXQUFPQyxHQUFQLENBQVdDLFNBQVgsQ0FBcUJILFFBQVFJLElBQTdCLEVBQW1DSixPQUFuQztBQUNIOztBQUVELGVBQWVBLE9BQWYiLCJmaWxlIjoidG9vbHRpcC5qcyIsInNvdXJjZVJvb3QiOiIvVXNlcnMvbWFjL2ludGVyZXN0aW5nL3Z1ZS90b29sdGlwIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFRvb2x0aXAgZnJvbSAnc3JjL1Rvb2x0aXAudnVlJ1xuXG5pZih3aW5kb3cuVnVlKSB7XG4gICAgd2luZG93LlZ1ZS5jb21wb25lbnQoVG9vbHRpcC5uYW1lLCBUb29sdGlwKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVG9vbHRpcFxuIl19\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_popper_js__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_popper_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_popper_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__bem_js__ = __webpack_require__(2);\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n// TODO: 确定是否写死触发方式\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = {\n    name: 'tooltip',\n    prefix: '',\n    props: {\n        placement: {\n            type: String,\n            default: 'bottom'\n        },\n        delay: {\n            type: Number,\n            default: 200\n        },\n        content: {\n            type: String,\n            default: ''\n        },\n        manual: {\n            type: Boolean,\n            default: false\n        },\n        disabled: {\n            type: Boolean,\n            default: false\n        },\n        value: {\n            type: Boolean,\n            default: false\n        }\n    },\n    data: function data() {\n        return {\n            isShow: false,\n            timeoutId: ''\n        };\n    },\n    render: function render(h) {\n        return h(\n            'span',\n            { 'class': [].concat(_toConsumableArray(this.cn())), on: {\n                    'mouseenter': this.manual ? this.fn : this.show,\n                    'mouseleave': this.manual ? this.fn : this.hide\n                }\n            },\n            [this.$slots.default, h(\n                'transition',\n                {\n                    attrs: { name: 'fade' }\n                },\n                [h(\n                    'div',\n                    { 'class': [].concat(_toConsumableArray(this.cn('content'))), ref: 'content', directives: [{\n                            name: 'show',\n                            value: !this.disabled && (this.manual ? this.value : this.isShow)\n                        }]\n                    },\n                    [this.$slots.content || this.content, h(\n                        'span',\n                        { 'class': [].concat(_toConsumableArray(this.cn('arrow'))), ref: 'arrow' },\n                        []\n                    )]\n                )]\n            )]\n        );\n    },\n    mounted: function mounted() {\n        this.popper = new __WEBPACK_IMPORTED_MODULE_0_popper_js___default.a(this.$el, this.$refs.content, {\n            placement: this.placement,\n            modifiers: { arrow: {\n                    element: this.$refs.arrow\n                } }\n        });\n    },\n\n    methods: {\n        cn: function cn(module, state) {\n            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__bem_js__[\"a\" /* prefixBem */])({\n                prefix: this.$options.prefix,\n                block: this.$options.name,\n                module: module,\n                state: state\n            });\n        },\n        fn: function fn() {},\n        show: function show() {\n            this.isShow = true;\n            this.popper.update();\n            clearTimeout(this.timeoutId);\n        },\n        hide: function hide() {\n            var _this = this;\n\n            this.timeoutId = setTimeout(function () {\n                _this.isShow = false;\n            }, this.delay);\n        }\n    }\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export bem */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return prefixBem; });\nvar bem = function bem(_ref) {\n    var block = _ref.block,\n        module = _ref.module,\n        state = _ref.state;\n\n    var name = '';\n    name += block;\n    if (module) {\n        name += '__' + module;\n    }\n    if (state) {\n        name += '--' + state;\n    }\n    return name;\n};\n\nvar prefixBem = function prefixBem(_ref2) {\n    var prefix = _ref2.prefix,\n        block = _ref2.block,\n        module = _ref2.module,\n        state = _ref2.state;\n\n    if (prefix) {\n        return [bem({ block: block, module: module, state: state }), prefix + '-' + bem({ block: block, module: module, state: state })];\n    } else {\n        return [bem({ block: block, module: module, state: state })];\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9iZW0uanMiXSwibmFtZXMiOlsiYmVtIiwiYmxvY2siLCJtb2R1bGUiLCJzdGF0ZSIsIm5hbWUiLCJwcmVmaXhCZW0iLCJwcmVmaXgiXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sSUFBSUEsTUFBTSxTQUFOQSxHQUFNLE9BQWlDO0FBQUEsUUFBdkJDLEtBQXVCLFFBQXZCQSxLQUF1QjtBQUFBLFFBQWhCQyxNQUFnQixRQUFoQkEsTUFBZ0I7QUFBQSxRQUFSQyxLQUFRLFFBQVJBLEtBQVE7O0FBQzlDLFFBQUlDLE9BQU8sRUFBWDtBQUNBQSxZQUFRSCxLQUFSO0FBQ0EsUUFBR0MsTUFBSCxFQUFXO0FBQ1BFLHVCQUFhRixNQUFiO0FBQ0g7QUFDRCxRQUFHQyxLQUFILEVBQVU7QUFDTkMsdUJBQWFELEtBQWI7QUFDSDtBQUNELFdBQU9DLElBQVA7QUFDSCxDQVZNOztBQVlQLE9BQU8sSUFBSUMsWUFBWSxTQUFaQSxTQUFZLFFBQXlDO0FBQUEsUUFBL0JDLE1BQStCLFNBQS9CQSxNQUErQjtBQUFBLFFBQXZCTCxLQUF1QixTQUF2QkEsS0FBdUI7QUFBQSxRQUFoQkMsTUFBZ0IsU0FBaEJBLE1BQWdCO0FBQUEsUUFBUkMsS0FBUSxTQUFSQSxLQUFROztBQUM1RCxRQUFHRyxNQUFILEVBQVc7QUFDUCxlQUFPLENBQUNOLElBQUksRUFBQ0MsWUFBRCxFQUFRQyxjQUFSLEVBQWdCQyxZQUFoQixFQUFKLENBQUQsRUFBaUNHLE1BQWpDLFNBQTJDTixJQUFJLEVBQUNDLFlBQUQsRUFBUUMsY0FBUixFQUFnQkMsWUFBaEIsRUFBSixDQUEzQyxDQUFQO0FBQ0gsS0FGRCxNQUVNO0FBQ0YsZUFBTyxDQUFDSCxJQUFJLEVBQUNDLFlBQUQsRUFBUUMsY0FBUixFQUFnQkMsWUFBaEIsRUFBSixDQUFELENBQVA7QUFDSDtBQUNKLENBTk0iLCJmaWxlIjoiYmVtLmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy9tYWMvaW50ZXJlc3RpbmcvdnVlL3Rvb2x0aXAiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIGJlbSA9IGZ1bmN0aW9uKHtibG9jaywgbW9kdWxlLCBzdGF0ZX0pIHtcbiAgICB2YXIgbmFtZSA9ICcnXG4gICAgbmFtZSArPSBibG9ja1xuICAgIGlmKG1vZHVsZSkge1xuICAgICAgICBuYW1lICs9IGBfXyR7bW9kdWxlfWBcbiAgICB9XG4gICAgaWYoc3RhdGUpIHtcbiAgICAgICAgbmFtZSArPSBgLS0ke3N0YXRlfWBcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5cbmV4cG9ydCB2YXIgcHJlZml4QmVtID0gZnVuY3Rpb24oe3ByZWZpeCwgYmxvY2ssIG1vZHVsZSwgc3RhdGV9KSB7XG4gICAgaWYocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBbYmVtKHtibG9jaywgbW9kdWxlLCBzdGF0ZX0pLCBgJHtwcmVmaXh9LSR7YmVtKHtibG9jaywgbW9kdWxlLCBzdGF0ZX0pfWBdXG4gICAgfWVsc2Uge1xuICAgICAgICByZXR1cm4gW2JlbSh7YmxvY2ssIG1vZHVsZSwgc3RhdGV9KV1cbiAgICB9XG59XG4iXX0=\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.0.8\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */    \n(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.Popper = factory());\n}(this, (function () { 'use strict';\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n    // NOTE: 1 DOM access here\n    var offsetParent = element.offsetParent;\n    var nodeName = offsetParent && offsetParent.nodeName;\n\n    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n        return window.document.documentElement;\n    }\n\n    return offsetParent;\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n        return [];\n    }\n    // NOTE: 1 DOM access here\n    var css = window.getComputedStyle(element, null);\n    return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n        return element;\n    }\n    return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element || ['HTML', 'BODY', '#document'].indexOf(element.nodeName) !== -1) {\n        return window.document.body;\n    }\n\n    // Firefox want us to check `-x` and `-y` variations as well\n\n    var _getStyleComputedProp = getStyleComputedProperty(element),\n        overflow = _getStyleComputedProp.overflow,\n        overflowX = _getStyleComputedProp.overflowX,\n        overflowY = _getStyleComputedProp.overflowY;\n\n    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {\n        return element;\n    }\n\n    return getScrollParent(getParentNode(element));\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n    var nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n        return true;\n    }\n    return isFixed(getParentNode(element));\n}\n\n/**\n * Helper used to get the position which will be applied to the popper\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element - popper element\n * @returns {String} position\n */\nfunction getPosition(element) {\n  var container = getOffsetParent(element);\n\n  // Decide if the popper will be fixed\n  // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together\n  var isParentFixed = isFixed(container);\n  return isParentFixed ? 'fixed' : 'absolute';\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles - result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {Number} borders - the borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return Number(styles['border' + sideA + 'Width'].split('px')[0]) + Number(styles['border' + sideB + 'Width'].split('px')[0]);\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n    var isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;\n    var rect = void 0;\n\n    // IE10 10 FIX: Please, don't ask, the element isn't\n    // considered in DOM in some circumstances...\n    // This isn't reproducible in IE10 compatibility mode of IE11\n    if (isIE10) {\n        try {\n            rect = element.getBoundingClientRect();\n        } catch (err) {\n            rect = {};\n        }\n    } else {\n        rect = element.getBoundingClientRect();\n    }\n\n    var result = {\n        left: rect.left,\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n    };\n\n    // IE10 FIX: `getBoundingClientRect`, when executed on `documentElement`\n    // will not take in account the `scrollTop` and `scrollLeft`\n    if (element.nodeName === 'HTML' && isIE10) {\n        var _window$document$docu = window.document.documentElement,\n            scrollTop = _window$document$docu.scrollTop,\n            scrollLeft = _window$document$docu.scrollLeft;\n\n        result.top -= scrollTop;\n        result.bottom -= scrollTop;\n        result.left -= scrollLeft;\n        result.right -= scrollLeft;\n    }\n\n    // subtract scrollbar size from sizes\n    var horizScrollbar = rect.width - (element.clientWidth || rect.right - rect.left);\n    var vertScrollbar = rect.height - (element.clientHeight || rect.bottom - rect.top);\n\n    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n    // we make this check conditional for performance reasons\n    if (horizScrollbar || vertScrollbar) {\n        var styles = getStyleComputedProperty(element);\n        horizScrollbar -= getBordersSize(styles, 'x');\n        vertScrollbar -= getBordersSize(styles, 'y');\n    }\n\n    result.right -= horizScrollbar;\n    result.width -= horizScrollbar;\n    result.bottom -= vertScrollbar;\n    result.height -= vertScrollbar;\n\n    return result;\n}\n\nfunction getScroll(element) {\n    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    var nodeName = element.nodeName;\n\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        var html = window.document.documentElement;\n        var scrollingElement = window.document.scrollingElement || html;\n        return scrollingElement[upperSide];\n    }\n\n    return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/**\n * Given an element and one of its parents, return the offset\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @param {HTMLElement} parent\n * @return {Object} rect\n */\nfunction getOffsetRectRelativeToCustomParent(element, parent) {\n    var fixed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var transformed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    var scrollParent = getScrollParent(parent);\n    var elementRect = getBoundingClientRect(element);\n    var parentRect = getBoundingClientRect(parent);\n\n    var rect = {\n        top: elementRect.top - parentRect.top,\n        left: elementRect.left - parentRect.left,\n        bottom: elementRect.top - parentRect.top + elementRect.height,\n        right: elementRect.left - parentRect.left + elementRect.width,\n        width: elementRect.width,\n        height: elementRect.height\n    };\n\n    if (fixed && !transformed) {\n        rect = includeScroll(rect, scrollParent, true);\n    }\n    // When a popper doesn't have any positioned or scrollable parents, `offsetParent.contains(scrollParent)`\n    // will return a \"false positive\". This is happening because `getOffsetParent` returns `html` node,\n    // and `scrollParent` is the `body` node. Hence the additional check.\n    else if (getOffsetParent(element).contains(scrollParent) && scrollParent.nodeName !== 'BODY') {\n            rect = includeScroll(rect, parent);\n        }\n\n    // subtract borderTopWidth and borderTopWidth from final result\n    var styles = getStyleComputedProperty(parent);\n    var borderTopWidth = Number(styles.borderTopWidth.split('px')[0]);\n    var borderLeftWidth = Number(styles.borderLeftWidth.split('px')[0]);\n\n    rect.top -= borderTopWidth;\n    rect.bottom -= borderTopWidth;\n    rect.left -= borderLeftWidth;\n    rect.right -= borderLeftWidth;\n\n    return rect;\n}\n\nfunction getWindowSizes() {\n    var body = window.document.body;\n    var html = window.document.documentElement;\n    return {\n        height: Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight),\n        width: Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth)\n    };\n}\n\n/**\n * Get the position of the given element, relative to its offset parent\n * @method\n * @memberof Popper.Utils\n * @param {Element} element\n * @return {Object} position - Coordinates of the element and its `scrollTop`\n */\nfunction getOffsetRect(element) {\n    var elementRect = void 0;\n    if (element.nodeName === 'HTML') {\n        var _getWindowSizes = getWindowSizes(),\n            width = _getWindowSizes.width,\n            height = _getWindowSizes.height;\n\n        elementRect = {\n            width: width,\n            height: height,\n            left: 0,\n            top: 0\n        };\n    } else {\n        elementRect = {\n            width: element.offsetWidth,\n            height: element.offsetHeight,\n            left: element.offsetLeft,\n            top: element.offsetTop\n        };\n    }\n\n    elementRect.right = elementRect.left + elementRect.width;\n    elementRect.bottom = elementRect.top + elementRect.height;\n\n    // position\n    return elementRect;\n}\n\nfunction getOffsetRectRelativeToViewport(element) {\n    // Offset relative to offsetParent\n    var relativeOffset = getOffsetRect(element);\n\n    if (element.nodeName !== 'HTML') {\n        var offsetParent = getOffsetParent(element);\n        var parentOffset = getOffsetRectRelativeToViewport(offsetParent);\n        var offset = {\n            width: relativeOffset.offsetWidth,\n            height: relativeOffset.offsetHeight,\n            left: relativeOffset.left + parentOffset.left,\n            top: relativeOffset.top + parentOffset.top,\n            right: relativeOffset.right - parentOffset.right,\n            bottom: relativeOffset.bottom - parentOffset.bottom\n        };\n        return offset;\n    }\n\n    return relativeOffset;\n}\n\nfunction getTotalScroll(element) {\n    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n    var scrollParent = getScrollParent(element);\n    var scroll = getScroll(scrollParent, side);\n\n    if (['BODY', 'HTML'].indexOf(scrollParent.nodeName) === -1) {\n        return scroll + getTotalScroll(getParentNode(scrollParent), side);\n    }\n    return scroll;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {Object} data - Object containing the property \"offsets\" generated by `_getOffsets`\n * @param {Number} padding - Boundaries padding\n * @param {Element} boundariesElement - Element used to define the boundaries\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, padding, boundariesElement) {\n    // NOTE: 1 DOM access here\n    var boundaries = { top: 0, left: 0 };\n    var offsetParent = getOffsetParent(popper);\n\n    // Handle viewport case\n    if (boundariesElement === 'viewport') {\n        var _getOffsetRectRelativ = getOffsetRectRelativeToViewport(offsetParent),\n            left = _getOffsetRectRelativ.left,\n            top = _getOffsetRectRelativ.top;\n\n        var _window$document$docu = window.document.documentElement,\n            width = _window$document$docu.clientWidth,\n            height = _window$document$docu.clientHeight;\n\n\n        if (getPosition(popper) === 'fixed') {\n            boundaries.right = width;\n            boundaries.bottom = height;\n        } else {\n            var scrollLeft = getTotalScroll(popper, 'left');\n            var scrollTop = getTotalScroll(popper, 'top');\n\n            boundaries = {\n                top: 0 - top,\n                right: width - left + scrollLeft,\n                bottom: height - top + scrollTop,\n                left: 0 - left\n            };\n        }\n    }\n    // Handle other cases based on DOM element used as boundaries\n    else {\n            var boundariesNode = void 0;\n            if (boundariesElement === 'scrollParent') {\n                boundariesNode = getScrollParent(getParentNode(popper));\n            } else if (boundariesElement === 'window') {\n                boundariesNode = window.document.body;\n            } else {\n                boundariesNode = boundariesElement;\n            }\n\n            // In case of BODY, we need a different computation\n            if (boundariesNode.nodeName === 'BODY') {\n                var _getWindowSizes = getWindowSizes(),\n                    _height = _getWindowSizes.height,\n                    _width = _getWindowSizes.width;\n\n                boundaries.right = _width;\n                boundaries.bottom = _height;\n            }\n            // for all the other DOM elements, this one is good\n            else {\n                    boundaries = getOffsetRectRelativeToCustomParent(boundariesNode, offsetParent, isFixed(popper));\n                }\n        }\n\n    // Add paddings\n    boundaries.left += padding;\n    boundaries.top += padding;\n    boundaries.right -= padding;\n    boundaries.bottom -= padding;\n\n    return boundaries;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper) {\n    if (placement.indexOf('auto') === -1) {\n        return placement;\n    }\n\n    var boundaries = getBoundaries(popper, 0, 'scrollParent');\n\n    var sides = {\n        top: refRect.top - boundaries.top,\n        right: boundaries.right - refRect.right,\n        bottom: boundaries.bottom - refRect.bottom,\n        left: refRect.left - boundaries.left\n    };\n\n    var computedPlacement = Object.keys(sides).sort(function (a, b) {\n        return sides[b] - sides[a];\n    })[0];\n    var variation = placement.split('-')[1];\n\n    return computedPlacement + (variation ? '-' + variation : '');\n}\n\nvar nativeHints = ['native code', '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n];\n\n/**\n * Determine if a function is implemented natively (as opposed to a polyfill).\n * @argument {Function | undefined} fn the function to check\n * @returns {boolean}\n */\nvar isNative = (function (fn) {\n  return nativeHints.some(function (hint) {\n    return (fn || '').toString().indexOf(hint) > -1;\n  });\n});\n\nvar isBrowser = typeof window !== 'undefined';\nvar longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nvar timeoutDuration = 0;\nfor (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n        timeoutDuration = 1;\n        break;\n    }\n}\n\nfunction microtaskDebounce(fn) {\n    var scheduled = false;\n    var i = 0;\n    var elem = document.createElement('span');\n\n    // MutationObserver provides a mechanism for scheduling microtasks, which\n    // are scheduled *before* the next task. This gives us a way to debounce\n    // a function but ensure it's called *before* the next paint.\n    var observer = new MutationObserver(function () {\n        fn();\n        scheduled = false;\n    });\n\n    observer.observe(elem, { attributes: true });\n\n    return function () {\n        if (!scheduled) {\n            scheduled = true;\n            elem.setAttribute('x-index', i);\n            i = i + 1; // don't use compund (+=) because it doesn't get optimized in V8\n        }\n    };\n}\n\nfunction taskDebounce(fn) {\n    var scheduled = false;\n    return function () {\n        if (!scheduled) {\n            scheduled = true;\n            setTimeout(function () {\n                scheduled = false;\n                fn();\n            }, timeoutDuration);\n        }\n    };\n}\n\n// It's common for MutationObserver polyfills to be seen in the wild, however\n// these rely on Mutation Events which only occur when an element is connected\n// to the DOM. The algorithm used in this module does not use a connected element,\n// and so we must ensure that a *native* MutationObserver is available.\nvar supportsNativeMutationObserver = isBrowser && isNative(window.MutationObserver);\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsNativeMutationObserver ? microtaskDebounce : taskDebounce;\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n    // use native find if supported\n    if (Array.prototype.find) {\n        return arr.find(check);\n    }\n\n    // use `filter` to obtain the same behavior of `find`\n    return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n    // use native findIndex if supported\n    if (Array.prototype.findIndex) {\n        return arr.findIndex(function (cur) {\n            return cur[prop] === value;\n        });\n    }\n\n    // use `find` + `indexOf` if `findIndex` isn't supported\n    var match = find(arr, function (obj) {\n        return obj[prop] === value;\n    });\n    return arr.indexOf(match);\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given the popper offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} popperOffsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(popperOffsets) {\n    return _extends({}, popperOffsets, {\n        right: popperOffsets.left + popperOffsets.width,\n        bottom: popperOffsets.top + popperOffsets.height\n    });\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n    var styles = window.getComputedStyle(element);\n    var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n    var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n    var result = {\n        width: element.offsetWidth + y,\n        height: element.offsetHeight + x\n    };\n    return result;\n}\n\n/**\n * Get the opposite placement of the given one/\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(position, popper, referenceOffsets, placement) {\n    placement = placement.split('-')[0];\n\n    // Get popper node sizes\n    var popperRect = getOuterSizes(popper);\n\n    // Add position, width and height to our offsets object\n    var popperOffsets = {\n        position: position,\n        width: popperRect.width,\n        height: popperRect.height\n    };\n\n    // depending by the popper placement we have to compute its offsets slightly differently\n    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    var mainSide = isHoriz ? 'top' : 'left';\n    var secondarySide = isHoriz ? 'left' : 'top';\n    var measurement = isHoriz ? 'height' : 'width';\n    var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n    if (placement === secondarySide) {\n        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n    } else {\n        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n    }\n\n    return popperOffsets;\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var isParentFixed = state.position === 'fixed';\n  var isParentTransformed = state.isParentTransformed;\n  var offsetParent = getOffsetParent(isParentFixed && isParentTransformed ? reference : popper);\n\n  return getOffsetRectRelativeToCustomParent(reference, offsetParent, isParentFixed, isParentTransformed);\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase)\n */\nfunction getSupportedPropertyName(property) {\n    var prefixes = [false, 'ms', 'webkit', 'moz', 'o'];\n    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n    for (var i = 0; i < prefixes.length - 1; i++) {\n        var prefix = prefixes[i];\n        var toCheck = prefix ? '' + prefix + upperProp : property;\n        if (typeof window.document.body.style[toCheck] !== 'undefined') {\n            return toCheck;\n        }\n    }\n    return null;\n}\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {*} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n    return modifiers.some(function (_ref) {\n        var name = _ref.name,\n            enabled = _ref.enabled;\n        return enabled && name === modifierName;\n    });\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n    var requesting = find(modifiers, function (_ref) {\n        var name = _ref.name;\n        return name === requestingName;\n    });\n\n    return !!requesting && modifiers.some(function (modifier) {\n        return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n    });\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Check if the given element has transforms applied to itself or a parent\n * @method\n * @memberof Popper.Utils\n * @param  {Element} element\n * @return {Boolean} answer to \"isTransformed?\"\n */\nfunction isTransformed(element) {\n    if (element.nodeName === 'BODY') {\n        return false;\n    }\n    if (getStyleComputedProperty(element, 'transform') !== 'none') {\n        return true;\n    }\n    return getParentNode(element) ? isTransformed(getParentNode(element)) : element;\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n    // Remove resize event listener on window\n    window.removeEventListener('resize', state.updateBound);\n\n    // Remove scroll event listener on scroll parents\n    state.scrollParents.forEach(function (target) {\n        target.removeEventListener('scroll', state.updateBound);\n    });\n\n    // Reset state\n    state.updateBound = null;\n    state.scrollParents = [];\n    state.scrollElement = null;\n    state.eventsEnabled = false;\n    return state;\n}\n\n/**\n * Loop trough the list of modifiers and run them in order, each of them will then edit the data object\n * @method\n * @memberof Popper.Utils\n * @param {Object} data\n * @param {Array} modifiers\n * @param {Function} ends\n */\nfunction runModifiers(modifiers, data, ends) {\n    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n    modifiersToRun.forEach(function (modifier) {\n        if (modifier.enabled && isFunction(modifier.function)) {\n            data = modifier.function(data, modifier);\n        }\n    });\n\n    return data;\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n    Object.keys(attributes).forEach(function (prop) {\n        var value = attributes[prop];\n        if (value !== false) {\n            element.setAttribute(prop, attributes[prop]);\n        } else {\n            element.removeAttribute(prop);\n        }\n    });\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n    Object.keys(styles).forEach(function (prop) {\n        var unit = '';\n        // add unit if the value is numeric and is one of the following\n        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n            unit = 'px';\n        }\n        element.style[prop] = styles[prop] + unit;\n    });\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n    var isBody = scrollParent.nodeName === 'BODY';\n    var target = isBody ? window : scrollParent;\n    target.addEventListener(event, callback, { passive: true });\n\n    if (!isBody) {\n        attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n    }\n    scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n    // Resize event listener on window\n    state.updateBound = updateBound;\n    window.addEventListener('resize', state.updateBound, { passive: true });\n\n    // Scroll event listener on scroll parents\n    var scrollElement = getScrollParent(reference);\n    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n    state.scrollElement = scrollElement;\n    state.eventsEnabled = true;\n\n    return state;\n}\n\n/** @namespace Popper.Utils */\nvar Utils = {\n    computeAutoPlacement: computeAutoPlacement,\n    debounce: debounce,\n    findIndex: findIndex,\n    getBordersSize: getBordersSize,\n    getBoundaries: getBoundaries,\n    getBoundingClientRect: getBoundingClientRect,\n    getClientRect: getClientRect,\n    getOffsetParent: getOffsetParent,\n    getOffsetRect: getOffsetRect,\n    getOffsetRectRelativeToCustomParent: getOffsetRectRelativeToCustomParent,\n    getOuterSizes: getOuterSizes,\n    getParentNode: getParentNode,\n    getPopperOffsets: getPopperOffsets,\n    getPosition: getPosition,\n    getReferenceOffsets: getReferenceOffsets,\n    getScroll: getScroll,\n    getScrollParent: getScrollParent,\n    getStyleComputedProperty: getStyleComputedProperty,\n    getSupportedPropertyName: getSupportedPropertyName,\n    getTotalScroll: getTotalScroll,\n    getWindowSizes: getWindowSizes,\n    includeScroll: includeScroll,\n    isFixed: isFixed,\n    isFunction: isFunction,\n    isModifierEnabled: isModifierEnabled,\n    isModifierRequired: isModifierRequired,\n    isNative: isNative,\n    isNumeric: isNumeric,\n    isTransformed: isTransformed,\n    removeEventListeners: removeEventListeners,\n    runModifiers: runModifiers,\n    setAttributes: setAttributes,\n    setStyles: setStyles,\n    setupEventListeners: setupEventListeners\n};\n\n/**\n * Apply the computed styles to the popper element\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data, options) {\n    // apply the final offsets to the popper\n    // NOTE: 1 DOM access here\n    var styles = {\n        position: data.offsets.popper.position\n    };\n\n    var attributes = {\n        'x-placement': data.placement\n    };\n\n    // round top and left to avoid blurry text\n    var left = Math.round(data.offsets.popper.left);\n    var top = Math.round(data.offsets.popper.top);\n\n    // if gpuAcceleration is set to true and transform is supported,\n    //  we use `translate3d` to apply the position to the popper we\n    // automatically use the supported prefixed version if needed\n    var prefixedProperty = getSupportedPropertyName('transform');\n    if (options.gpuAcceleration && prefixedProperty) {\n        styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n        styles.top = 0;\n        styles.left = 0;\n        styles.willChange = 'transform';\n    }\n    // othwerise, we use the standard `left` and `top` properties\n    else {\n            styles.left = left;\n            styles.top = top;\n            styles.willChange = 'top, left';\n        }\n\n    // any property present in `data.styles` will be applied to the popper,\n    // in this way we can make the 3rd party modifiers add custom styles to it\n    // Be aware, modifiers could override the properties defined in the previous\n    // lines of this modifier!\n    setStyles(data.instance.popper, _extends({}, styles, data.styles));\n\n    // any property present in `data.attributes` will be applied to the popper,\n    // they will be set as HTML attributes of the element\n    setAttributes(data.instance.popper, _extends({}, attributes, data.attributes));\n\n    // if the arrow style has been computed, apply the arrow style\n    if (data.offsets.arrow) {\n        setStyles(data.arrowElement, data.offsets.arrow);\n    }\n\n    return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used to add margins to the popper\n * margins needs to be calculated to get the correct popper offsets\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper.\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n    // compute reference element offsets\n    var referenceOffsets = getReferenceOffsets(state, popper, reference);\n\n    // compute auto placement, store placement inside the data object,\n    // modifiers will be able to edit `placement` if needed\n    // and refer to originalPlacement to know the original value\n    options.placement = computeAutoPlacement(options.placement, referenceOffsets, popper);\n\n    popper.setAttribute('x-placement', options.placement);\n    return options;\n}\n\n/**\n * Modifier used to move the arrowElements on the edge of the popper to make sure them are always between the popper and the reference element\n * It will use the CSS outer size of the arrowElement element to know how many pixels of conjuction are needed\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n    // arrow depends on keepTogether in order to work\n    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n        console.warn('WARNING: `keepTogether` modifier is required by arrow modifier in order to work, be sure to include it before `arrow`!');\n        return data;\n    }\n\n    var arrowElement = options.element;\n\n    // if arrowElement is a string, suppose it's a CSS selector\n    if (typeof arrowElement === 'string') {\n        arrowElement = data.instance.popper.querySelector(arrowElement);\n\n        // if arrowElement is not found, don't run the modifier\n        if (!arrowElement) {\n            return data;\n        }\n    } else {\n        // if the arrowElement isn't a query selector we must check that the\n        // provided DOM node is child of its popper node\n        if (!data.instance.popper.contains(arrowElement)) {\n            console.warn('WARNING: `arrow.element` must be child of its popper element!');\n            return data;\n        }\n    }\n\n    var placement = data.placement.split('-')[0];\n    var popper = getClientRect(data.offsets.popper);\n    var reference = data.offsets.reference;\n    var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n    var len = isVertical ? 'height' : 'width';\n    var side = isVertical ? 'top' : 'left';\n    var altSide = isVertical ? 'left' : 'top';\n    var opSide = isVertical ? 'bottom' : 'right';\n    var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n    //\n    // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction\n    //\n\n    // top/left side\n    if (reference[opSide] - arrowElementSize < popper[side]) {\n        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n    }\n    // bottom/right side\n    if (reference[side] + arrowElementSize > popper[opSide]) {\n        data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n    }\n\n    // compute center of the popper\n    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n    // Compute the sideValue using the updated popper offsets\n    var sideValue = center - getClientRect(data.offsets.popper)[side];\n\n    // prevent arrowElement from being placed not contiguously to its popper\n    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n    data.arrowElement = arrowElement;\n    data.offsets.arrow = {};\n    data.offsets.arrow[side] = sideValue;\n    data.offsets.arrow[altSide] = ''; // make sure to unset any eventual altSide value from the DOM node\n\n    return data;\n}\n\n/**\n * Get the opposite placement variation of the given one/\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n    if (variation === 'end') {\n        return 'start';\n    } else if (variation === 'start') {\n        return 'end';\n    }\n    return variation;\n}\n\n/**\n * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.\n * Requires the `preventOverflow` modifier before it in order to work.\n * **NOTE:** data.instance modifier will run all its previous modifiers everytime it tries to flip the popper!\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n    // if `inner` modifier is enabled, we can't use the `flip` modifier\n    if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n        return data;\n    }\n\n    if (data.flipped && data.placement === data.originalPlacement) {\n        // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n        return data;\n    }\n\n    var boundaries = getBoundaries(data.instance.popper, options.padding, options.boundariesElement);\n\n    var placement = data.placement.split('-')[0];\n    var placementOpposite = getOppositePlacement(placement);\n    var variation = data.placement.split('-')[1] || '';\n\n    var flipOrder = [];\n\n    if (options.behavior === 'flip') {\n        flipOrder = [placement, placementOpposite];\n    } else {\n        flipOrder = options.behavior;\n    }\n\n    flipOrder.forEach(function (step, index) {\n        if (placement !== step || flipOrder.length === index + 1) {\n            return data;\n        }\n\n        placement = data.placement.split('-')[0];\n        placementOpposite = getOppositePlacement(placement);\n\n        var popperOffsets = getClientRect(data.offsets.popper);\n        var refOffsets = data.offsets.reference;\n\n        // using floor because the reference offsets may contain decimals we are not going to consider here\n        var floor = Math.floor;\n        var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n        var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n        var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n        var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n        var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n        var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n        // flip the variation if required\n        var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n        var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n        if (overlapsRef || overflowsBoundaries || flippedVariation) {\n            // this boolean to detect any flip loop\n            data.flipped = true;\n\n            if (overlapsRef || overflowsBoundaries) {\n                placement = flipOrder[index + 1];\n            }\n\n            if (flippedVariation) {\n                variation = getOppositeVariation(variation);\n            }\n\n            data.placement = placement + (variation ? '-' + variation : '');\n            data.offsets.popper = getPopperOffsets(data.instance.state.position, data.instance.popper, data.offsets.reference, data.placement);\n\n            data = runModifiers(data.instance.modifiers, data, 'flip');\n        }\n    });\n    return data;\n}\n\n/**\n * Modifier used to make sure the popper is always near its reference element\n * It cares only about the first axis, you can still have poppers with margin\n * between the popper and its reference element.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n    var popper = getClientRect(data.offsets.popper);\n    var reference = data.offsets.reference;\n    var placement = data.placement.split('-')[0];\n    var floor = Math.floor;\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    var side = isVertical ? 'right' : 'bottom';\n    var opSide = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    if (popper[side] < floor(reference[opSide])) {\n        data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n    }\n    if (popper[opSide] > floor(reference[side])) {\n        data.offsets.popper[opSide] = floor(reference[side]);\n    }\n\n    return data;\n}\n\n/**\n * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.\n * The offsets will shift the popper on the side of its reference element.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n *      Basic usage allows a number used to nudge the popper by the given amount of pixels.\n *      You can pass a percentage value as string (eg. `20%`) to nudge by the given percentage (relative to reference element size)\n *      Other supported units are `vh` and `vw` (relative to viewport)\n *      Additionally, you can pass a pair of values (eg. `10 20` or `2vh 20%`) to nudge the popper\n *      on both axis.\n *      A note about percentage values, if you want to refer a percentage to the popper size instead of the reference element size,\n *      use `%p` instead of `%` (eg: `20%p`). To make it clearer, you can replace `%` with `%r` and use eg.`10%p 25%r`.\n *      > **Heads up!** The order of the axis is relative to the popper placement: `bottom` or `top` are `X,Y`, the other are `Y,X`\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, options) {\n    var placement = data.placement;\n    var popper = data.offsets.popper;\n\n    var offsets = void 0;\n    if (isNumeric(options.offset)) {\n        offsets = [options.offset, 0];\n    } else {\n        // split the offset in case we are providing a pair of offsets separated\n        // by a blank space\n        offsets = options.offset.split(' ');\n\n        // itherate through each offset to compute them in case they are percentages\n        offsets = offsets.map(function (offset, index) {\n            // separate value from unit\n            var split = offset.match(/(\\d*\\.?\\d*)(.*)/);\n            var value = +split[1];\n            var unit = split[2];\n\n            // use height if placement is left or right and index is 0 otherwise use width\n            // in this way the first offset will use an axis and the second one\n            // will use the other one\n            var useHeight = placement.indexOf('right') !== -1 || placement.indexOf('left') !== -1;\n\n            if (index === 1) {\n                useHeight = !useHeight;\n            }\n\n            var measurement = useHeight ? 'height' : 'width';\n\n            // if is a percentage relative to the popper (%p), we calculate the value of it using\n            // as base the sizes of the popper\n            // if is a percentage (% or %r), we calculate the value of it using as base the\n            // sizes of the reference element\n            if (unit.indexOf('%') === 0) {\n                var element = void 0;\n                switch (unit) {\n                    case '%p':\n                        element = data.offsets.popper;\n                        break;\n                    case '%':\n                    case '$r':\n                    default:\n                        element = data.offsets.reference;\n                }\n\n                var rect = getClientRect(element);\n                var len = rect[measurement];\n                return len / 100 * value;\n            }\n            // if is a vh or vw, we calculate the size based on the viewport\n            else if (unit === 'vh' || unit === 'vw') {\n                    var size = void 0;\n                    if (unit === 'vh') {\n                        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n                    } else {\n                        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n                    }\n                    return size / 100 * value;\n                }\n                // if is an explicit pixel unit, we get rid of the unit and keep the value\n                else if (unit === 'px') {\n                        return +value;\n                    }\n                    // if is an implicit unit, it's px, and we return just the value\n                    else {\n                            return +offset;\n                        }\n        });\n    }\n\n    if (data.placement.indexOf('left') !== -1) {\n        popper.top += offsets[0];\n        popper.left -= offsets[1] || 0;\n    } else if (data.placement.indexOf('right') !== -1) {\n        popper.top += offsets[0];\n        popper.left += offsets[1] || 0;\n    } else if (data.placement.indexOf('top') !== -1) {\n        popper.left += offsets[0];\n        popper.top -= offsets[1] || 0;\n    } else if (data.placement.indexOf('bottom') !== -1) {\n        popper.left += offsets[0];\n        popper.top += offsets[1] || 0;\n    }\n    return data;\n}\n\n/**\n * Modifier used to prevent the popper from being positioned outside the boundary.\n *\n * An scenario exists where the reference itself is not within the boundaries. We can\n * say it has \"escaped the boundaries\" — or just \"escaped\". In this case we need to\n * decide whether the popper should either:\n *\n * - detach from the reference and remain \"trapped\" in the boundaries, or\n * - if it should be ignore the boundary and \"escape with the reference\"\n *\n * When `escapeWithReference` is `true`, and reference is completely outside the\n * boundaries, the popper will overflow (or completely leave) the boundaries in order\n * to remain attached to the edge of the reference.\n *\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n    var boundaries = getBoundaries(data.instance.popper, options.padding, boundariesElement);\n    options.boundaries = boundaries;\n\n    var order = options.priority;\n    var popper = getClientRect(data.offsets.popper);\n\n    var check = {\n        primary: function primary(placement) {\n            var value = popper[placement];\n            if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n                value = Math.max(popper[placement], boundaries[placement]);\n            }\n            return defineProperty({}, placement, value);\n        },\n        secondary: function secondary(placement) {\n            var mainSide = placement === 'right' ? 'left' : 'top';\n            var value = popper[mainSide];\n            if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n                value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n            }\n            return defineProperty({}, mainSide, value);\n        }\n    };\n\n    order.forEach(function (placement) {\n        var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n        popper = _extends({}, popper, check[side](placement));\n    });\n\n    data.offsets.popper = popper;\n\n    return data;\n}\n\n/**\n * Modifier used to shift the popper on the start or end of its reference element side\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n    var placement = data.placement;\n    var basePlacement = placement.split('-')[0];\n    var shiftvariation = placement.split('-')[1];\n\n    // if shift shiftvariation is specified, run the modifier\n    if (shiftvariation) {\n        var reference = data.offsets.reference;\n        var popper = getClientRect(data.offsets.popper);\n        var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n        var side = isVertical ? 'left' : 'top';\n        var measurement = isVertical ? 'width' : 'height';\n\n        var shiftOffsets = {\n            start: defineProperty({}, side, reference[side]),\n            end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n        };\n\n        data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n    }\n\n    return data;\n}\n\n/**\n * Modifier used to hide the popper when its reference element is outside of the\n * popper boundaries. It will set an x-hidden attribute which can be used to hide\n * the popper when its reference is out of boundaries.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n        console.warn('WARNING: preventOverflow modifier is required by hide modifier in order to work, be sure to include it before hide!');\n        return data;\n    }\n\n    var refRect = data.offsets.reference;\n    var bound = find(data.instance.modifiers, function (modifier) {\n        return modifier.name === 'preventOverflow';\n    }).boundaries;\n\n    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n        // Avoid unnecessary DOM access if visibility hasn't changed\n        if (data.hide === true) {\n            return data;\n        }\n\n        data.hide = true;\n        data.attributes['x-out-of-boundaries'] = '';\n    } else {\n        // Avoid unnecessary DOM access if visibility hasn't changed\n        if (data.hide === false) {\n            return data;\n        }\n\n        data.hide = false;\n        data.attributes['x-out-of-boundaries'] = false;\n    }\n\n    return data;\n}\n\n/**\n * Modifier used to make the popper flow toward the inner of the reference element.\n * By default, when this modifier is disabled, the popper will be placed outside\n * the reference element.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n    var placement = data.placement;\n    var basePlacement = placement.split('-')[0];\n    var popper = getClientRect(data.offsets.popper);\n    var reference = getClientRect(data.offsets.reference);\n    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n    popper[isHoriz ? 'left' : 'top'] = reference[placement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n    data.placement = getOppositePlacement(placement);\n    data.offsets.popper = getClientRect(popper);\n\n    return data;\n}\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.\n * Popper.js uses a set of 7 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Each modifier is an object containing several properties listed below.\n * @namespace Modifiers\n * @param {Object} modifier - Modifier descriptor\n * @param {Integer} modifier.order\n *      The `order` property defines the execution order of the modifiers.\n *      The built-in modifiers have orders with a gap of 100 units in between,\n *      this allows you to inject additional modifiers between the existing ones\n *      without having to redefine the order of all of them.\n *      The modifiers are executed starting from the one with the lowest order.\n * @param {Boolean} modifier.enabled - When `true`, the modifier will be used.\n * @param {Modifiers~modifier} modifier.function - Modifier function.\n * @param {Modifiers~onLoad} modifier.onLoad - Function executed on popper initalization\n * @return {Object} data - Each modifier must return the modified `data` object.\n */\nvar modifiers = {\n  shift: {\n    order: 100,\n    enabled: true,\n    function: shift\n  },\n  offset: {\n    order: 200,\n    enabled: true,\n    function: offset,\n    // nudges popper from its origin by the given amount of pixels (can be negative)\n    offset: 0\n  },\n  preventOverflow: {\n    order: 300,\n    enabled: true,\n    function: preventOverflow,\n    // popper will try to prevent overflow following these priorities\n    //  by default, then, it could overflow on the left and on top of the boundariesElement\n    priority: ['left', 'right', 'top', 'bottom'],\n    // amount of pixel used to define a minimum distance between the boundaries and the popper\n    // this makes sure the popper has always a little padding between the edges of its container\n    padding: 5,\n    boundariesElement: 'scrollParent'\n  },\n  keepTogether: {\n    order: 400,\n    enabled: true,\n    function: keepTogether\n  },\n  arrow: {\n    order: 500,\n    enabled: true,\n    function: arrow,\n    // selector or node used as arrow\n    element: '[x-arrow]'\n  },\n  flip: {\n    order: 600,\n    enabled: true,\n    function: flip,\n    // the behavior used to change the popper's placement\n    behavior: 'flip',\n    // the popper will flip if it hits the edges of the boundariesElement - padding\n    padding: 5,\n    boundariesElement: 'viewport'\n  },\n  inner: {\n    order: 700,\n    enabled: false,\n    function: inner\n  },\n  hide: {\n    order: 800,\n    enabled: true,\n    function: hide\n  },\n  applyStyle: {\n    order: 900,\n    enabled: true,\n    // if true, it uses the CSS 3d transformation to position the popper\n    gpuAcceleration: true,\n    function: applyStyle,\n    onLoad: applyStyleOnLoad\n  }\n};\n\n/**\n * Modifiers can edit the `data` object to change the beheavior of the popper.\n * This object contains all the informations used by Popper.js to compute the\n * popper position.\n * The modifier can edit the data as needed, and then `return` it as result.\n *\n * @callback Modifiers~modifier\n * @param {dataObject} data\n * @return {dataObject} modified data\n */\n\n/**\n * The `dataObject` is an object containing all the informations used by Popper.js\n * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements.\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arro] `top` and `left` offsets, only one of them will be different from 0\n */\n\n// Utils\n// Modifiers\n// default options\nvar DEFAULTS = {\n    // placement of the popper\n    placement: 'bottom',\n\n    // whether events (resize, scroll) are initially enabled\n    eventsEnabled: true,\n\n    /**\n     * Callback called when the popper is created.\n     * By default, is set to no-op.\n     * Access Popper.js instance with `data.instance`.\n     * @callback createCallback\n     * @static\n     * @param {dataObject} data\n     */\n    onCreate: function onCreate() {},\n\n    /**\n     * Callback called when the popper is updated, this callback is not called\n     * on the initialization/creation of the popper, but only on subsequent\n     * updates.\n     * By default, is set to no-op.\n     * Access Popper.js instance with `data.instance`.\n     * @callback updateCallback\n     * @static\n     * @param {dataObject} data\n     */\n    onUpdate: function onUpdate() {},\n\n    // list of functions used to modify the offsets before they are applied to the popper\n    modifiers: modifiers\n};\n\n/**\n * Create a new Popper.js instance\n * @class Popper\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper.\n * @param {Object} options\n * @param {String} options.placement=bottom\n *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),\n *      left(-start, -end)`\n *\n * @param {Boolean} options.eventsEnabled=true\n *      Whether events (resize, scroll) are initially enabled\n * @param {Boolean} options.gpuAcceleration=true\n *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the\n *      browser to use the GPU to accelerate the rendering.\n *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.\n *\n * @param {Boolean} options.removeOnDestroy=false\n *      Set to true if you want to automatically remove the popper when you call the `destroy` method.\n *\n * @param {Object} options.modifiers\n *      List of functions used to modify the data before they are applied to the popper (see source code for default values)\n *\n * @param {Object} options.modifiers.arrow - Arrow modifier configuration\n * @param {String|HTMLElement} options.modifiers.arrow.element='[x-arrow]'\n *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of\n *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its\n *      reference element.\n *      By default, it will look for a child node of the popper with the `x-arrow` attribute.\n *\n * @param {Object} options.modifiers.offset - Offset modifier configuration\n * @param {Number} options.modifiers.offset.offset=0\n *      Amount of pixels the popper will be shifted (can be negative).\n *\n * @param {Object} options.modifiers.preventOverflow - PreventOverflow modifier configuration\n * @param {Array} [options.modifiers.preventOverflow.priority=['left', 'right', 'top', 'bottom']]\n *      Priority used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,\n *      this means that the last one will never overflow\n * @param {String|HTMLElement} options.modifiers.preventOverflow.boundariesElement='scrollParent'\n *      Boundaries used by the modifier, can be `scrollParent`, `window`, `viewport` or any DOM element.\n * @param {Number} options.modifiers.preventOverflow.padding=5\n *      Amount of pixel used to define a minimum distance between the boundaries and the popper\n *      this makes sure the popper has always a little padding between the edges of its container.\n *\n * @param {Object} options.modifiers.flip - Flip modifier configuration\n * @param {String|Array} options.modifiers.flip.behavior='flip'\n *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to\n *      overlap its reference element. Defining `flip` as value, the placement will be flipped on\n *      its axis (`right - left`, `top - bottom`).\n *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify\n *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,\n *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)\n * @param {String|HTMLElement} options.modifiers.flip.boundariesElement='viewport'\n *      The element which will define the boundaries of the popper position, the popper will never be placed outside\n *      of the defined boundaries (except if `keepTogether` is enabled)\n *\n * @param {Object} options.modifiers.inner - Inner modifier configuration\n * @param {Number} options.modifiers.inner.enabled=false\n *      Set to `true` to make the popper flow toward the inner of the reference element.\n *\n * @param {Number} options.modifiers.flip.padding=5\n *      Amount of pixel used to define a minimum distance between the boundaries and the popper\n *      this makes sure the popper has always a little padding between the edges of its container.\n *\n * @param {createCallback} options.onCreate - onCreate callback\n *      Function called after the Popper has been instantiated.\n *\n * @param {updateCallback} options.onUpdate - onUpdate callback\n *      Function called on subsequent updates of Popper.\n *\n * @return {Object} instance - The generated Popper.js instance\n */\n\nvar Popper = function () {\n    function Popper(reference, popper) {\n        var _this = this;\n\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        classCallCheck(this, Popper);\n\n        this.scheduleUpdate = function () {\n            return requestAnimationFrame(_this.update);\n        };\n\n        // make update() debounced, so that it only runs at most once-per-tick\n        this.update = debounce(this.update.bind(this));\n\n        // with {} we create a new object with the options inside it\n        this.options = _extends({}, Popper.Defaults, options);\n\n        // init state\n        this.state = {\n            isDestroyed: false,\n            isCreated: false,\n            scrollParents: []\n        };\n\n        // get reference and popper elements (allow jQuery wrappers)\n        this.reference = reference.jquery ? reference[0] : reference;\n        this.popper = popper.jquery ? popper[0] : popper;\n\n        // refactoring modifiers' list (Object => Array)\n        this.modifiers = Object.keys(Popper.Defaults.modifiers).map(function (name) {\n            return _extends({ name: name }, Popper.Defaults.modifiers[name]);\n        });\n\n        // assign default values to modifiers, making sure to override them with\n        // the ones defined by user\n        this.modifiers = this.modifiers.map(function (defaultConfig) {\n            var userConfig = options.modifiers && options.modifiers[defaultConfig.name] || {};\n            return _extends({}, defaultConfig, userConfig);\n        });\n\n        // add custom modifiers to the modifiers list\n        if (options.modifiers) {\n            this.options.modifiers = _extends({}, Popper.Defaults.modifiers, options.modifiers);\n            Object.keys(options.modifiers).forEach(function (name) {\n                // take in account only custom modifiers\n                if (Popper.Defaults.modifiers[name] === undefined) {\n                    var modifier = options.modifiers[name];\n                    modifier.name = name;\n                    _this.modifiers.push(modifier);\n                }\n            });\n        }\n\n        // get the popper position type\n        this.state.position = getPosition(this.reference);\n\n        // sort the modifiers by order\n        this.modifiers = this.modifiers.sort(function (a, b) {\n            return a.order - b.order;\n        });\n\n        // modifiers have the ability to execute arbitrary code when Popper.js get inited\n        // such code is executed in the same order of its modifier\n        // they could add new properties to their options configuration\n        // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n        this.modifiers.forEach(function (modifierOptions) {\n            if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n                modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n            }\n        });\n\n        // determine how we should set the origin of offsets\n        this.state.isParentTransformed = isTransformed(this.popper.parentNode);\n\n        // fire the first update to position the popper in the right place\n        this.update();\n\n        var eventsEnabled = this.options.eventsEnabled;\n        if (eventsEnabled) {\n            // setup event listeners, they will take care of update the position in specific situations\n            this.enableEventListeners();\n        }\n\n        this.state.eventsEnabled = eventsEnabled;\n    }\n\n    //\n    // Methods\n    //\n\n    /**\n     * Updates the position of the popper, computing the new offsets and applying the new style\n     * Prefer `scheduleUpdate` over `update` because of performance reasons\n     * @method\n     * @memberof Popper\n     */\n\n\n    createClass(Popper, [{\n        key: 'update',\n        value: function update() {\n            // if popper is destroyed, don't perform any further update\n            if (this.state.isDestroyed) {\n                return;\n            }\n\n            var data = {\n                instance: this,\n                styles: {},\n                attributes: {},\n                flipped: false,\n                offsets: {}\n            };\n\n            // make sure to apply the popper position before any computation\n            this.state.position = getPosition(this.reference);\n            setStyles(this.popper, { position: this.state.position });\n\n            // compute reference element offsets\n            data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);\n\n            // compute auto placement, store placement inside the data object,\n            // modifiers will be able to edit `placement` if needed\n            // and refer to originalPlacement to know the original value\n            data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper);\n\n            // store the computed placement inside `originalPlacement`\n            data.originalPlacement = this.options.placement;\n\n            // compute the popper offsets\n            data.offsets.popper = getPopperOffsets(this.state, this.popper, data.offsets.reference, data.placement);\n\n            // run the modifiers\n            data = runModifiers(this.modifiers, data);\n\n            // the first `update` will call `onCreate` callback\n            // the other ones will call `onUpdate` callback\n            if (!this.state.isCreated) {\n                this.state.isCreated = true;\n                this.options.onCreate(data);\n            } else {\n                this.options.onUpdate(data);\n            }\n        }\n\n        /**\n         * Schedule an update, it will run on the next UI update available\n         * @method scheduleUpdate\n         * @memberof Popper\n         */\n\n    }, {\n        key: 'destroy',\n\n\n        /**\n         * Destroy the popper\n         * @method\n         * @memberof Popper\n         */\n        value: function destroy() {\n            this.state.isDestroyed = true;\n\n            // touch DOM only if `applyStyle` modifier is enabled\n            if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n                this.popper.removeAttribute('x-placement');\n                this.popper.style.left = '';\n                this.popper.style.position = '';\n                this.popper.style.top = '';\n                this.popper.style[getSupportedPropertyName('transform')] = '';\n            }\n\n            this.disableEventListeners();\n\n            // remove the popper if user explicity asked for the deletion on destroy\n            // do not use `remove` because IE11 doesn't support it\n            if (this.options.removeOnDestroy) {\n                this.popper.parentNode.removeChild(this.popper);\n            }\n            return this;\n        }\n\n        /**\n         * it will add resize/scroll events and start recalculating\n         * position of the popper element when they are triggered\n         * @method\n         * @memberof Popper\n         */\n\n    }, {\n        key: 'enableEventListeners',\n        value: function enableEventListeners() {\n            if (!this.state.eventsEnabled) {\n                this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n            }\n        }\n\n        /**\n         * it will remove resize/scroll events and won't recalculate\n         * popper position when they are triggered. It also won't trigger onUpdate callback anymore,\n         * unless you call 'update' method manually.\n         * @method\n         * @memberof Popper\n         */\n\n    }, {\n        key: 'disableEventListeners',\n        value: function disableEventListeners() {\n            if (this.state.eventsEnabled) {\n                window.cancelAnimationFrame(this.scheduleUpdate);\n                this.state = removeEventListeners(this.reference, this.state);\n            }\n        }\n\n        /**\n         * Collection of utilities useful when writing custom modifiers\n         * @memberof Popper\n         */\n\n\n        /**\n         * List of accepted placements to use as values of the `placement` option\n         * @memberof Popper\n         */\n\n\n        /**\n         * Default Popper.js options\n         * @memberof Popper\n         */\n\n    }]);\n    return Popper;\n}();\n\nPopper.Utils = Utils;\nPopper.placements = ['auto', 'auto-start', 'auto-end', 'top', 'top-start', 'top-end', 'right', 'right-start', 'right-end', 'bottom', 'bottom-start', 'bottom-end', 'left', 'left-start', 'left-end'];\nPopper.Defaults = DEFAULTS;\n\nreturn Popper;\n\n})));\n//# sourceMappingURL=popper.es5.js.map\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/* styles */\n__webpack_require__(4)\n\nvar Component = __webpack_require__(6)(\n  /* script */\n  __webpack_require__(1),\n  /* template */\n  null,\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// tooltip.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4946f3fa12d5e3a2f8f7","import Tooltip from 'src/Tooltip.vue'\n\nif(window.Vue) {\n    window.Vue.component(Tooltip.name, Tooltip);\n}\n\nexport default Tooltip\n\n\n\n// WEBPACK FOOTER //\n// ./tooltip.js","<script>\n// TODO: 确定是否写死触发方式\nimport Popper from 'popper.js'\nimport {prefixBem} from './bem.js'\nexport default {\n    name: 'tooltip',\n    prefix: '',\n    props: {\n        placement: {\n            type: String,\n            default: 'bottom'\n        },\n        delay: {\n            type: Number,\n            default:  200\n        },\n        content: {\n            type: String,\n            default: ''\n        },\n        manual: {\n            type: Boolean,\n            default: false\n        },\n        disabled: {\n            type: Boolean,\n            default: false\n        },\n        value: {\n            type: Boolean,\n            default: false\n        }\n    },\n    data() {\n        return {\n            isShow: false,\n            timeoutId: ''\n        }\n    },\n    render(h) {\n        return <span class={[...this.cn()]} onMouseenter={this.manual?this.fn:this.show} onMouseleave={this.manual?this.fn:this.hide}>\n            { this.$slots.default }\n            <transition name=\"fade\">\n                <div class={[...this.cn('content')]} ref=\"content\" v-show={!this.disabled&&(this.manual?this.value:this.isShow)}>\n                    { this.$slots.content || this.content }\n                    <span class={[...this.cn('arrow')]} ref=\"arrow\"></span>\n                </div>\n            </transition>\n\n        </span>\n    },\n    mounted() {\n        this.popper = new Popper(this.$el, this.$refs.content, {\n            placement: this.placement,\n            modifiers: {arrow: {\n                element: this.$refs.arrow\n            }}\n        })\n    },\n    methods: {\n        cn(module, state) {\n            return prefixBem({\n                prefix: this.$options.prefix,\n                block: this.$options.name,\n                module: module,\n                state: state\n            })\n        },\n        fn(){},\n        show() {\n            this.isShow = true;\n            this.popper.update();\n            clearTimeout(this.timeoutId);\n        },\n        hide() {\n            this.timeoutId = setTimeout(()=>{\n                this.isShow = false;\n            },this.delay)\n        }\n    }\n}\n</script>\n<style media=\"screen\" lang=\"less\">\n    [x-placement^=left] {\n        margin-right: 10px;\n        .tooltip__arrow {\n            right: -5px;\n            border-right-width: 0;\n            border-top-color: transparent;\n            border-bottom-color: transparent;\n        }\n    }\n    [x-placement^=right] {\n        margin-left: 10px;\n        .tooltip__arrow {\n            left: -5px;\n            border-left-width: 0;\n            border-top-color: transparent;\n            border-bottom-color: transparent;\n        }\n    }\n    [x-placement^=top] {\n        margin-bottom: 10px;\n        .tooltip__arrow {\n            bottom: -5px;\n            border-bottom-width: 0;\n            border-left-color: transparent;\n            border-right-color: transparent;\n        }\n    }\n    [x-placement^=bottom] {\n        margin-top: 10px;\n        .tooltip__arrow {\n            top: -5px;\n            border-top-width: 0;\n            border-left-color: transparent;\n            border-right-color: transparent;\n        }\n    }\n    .tooltip {\n        &__content{\n            background: #ccc;\n            padding: 10px;\n        }\n\n        &__arrow {\n            position: absolute;\n            display: block;\n            width: 0;\n            height: 0;\n            border-color: #ccc;\n            border-style: solid;\n            border-width: 5px;\n        }\n    }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// Tooltip.vue?a59f606e","export var bem = function({block, module, state}) {\n    var name = ''\n    name += block\n    if(module) {\n        name += `__${module}`\n    }\n    if(state) {\n        name += `--${state}`\n    }\n    return name;\n}\n\nexport var prefixBem = function({prefix, block, module, state}) {\n    if(prefix) {\n        return [bem({block, module, state}), `${prefix}-${bem({block, module, state})}`]\n    }else {\n        return [bem({block, module, state})]\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/bem.js","/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.0.8\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */    \n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.Popper = factory());\n}(this, (function () { 'use strict';\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n    // NOTE: 1 DOM access here\n    var offsetParent = element.offsetParent;\n    var nodeName = offsetParent && offsetParent.nodeName;\n\n    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n        return window.document.documentElement;\n    }\n\n    return offsetParent;\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n        return [];\n    }\n    // NOTE: 1 DOM access here\n    var css = window.getComputedStyle(element, null);\n    return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n        return element;\n    }\n    return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element || ['HTML', 'BODY', '#document'].indexOf(element.nodeName) !== -1) {\n        return window.document.body;\n    }\n\n    // Firefox want us to check `-x` and `-y` variations as well\n\n    var _getStyleComputedProp = getStyleComputedProperty(element),\n        overflow = _getStyleComputedProp.overflow,\n        overflowX = _getStyleComputedProp.overflowX,\n        overflowY = _getStyleComputedProp.overflowY;\n\n    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {\n        return element;\n    }\n\n    return getScrollParent(getParentNode(element));\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n    var nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n        return true;\n    }\n    return isFixed(getParentNode(element));\n}\n\n/**\n * Helper used to get the position which will be applied to the popper\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element - popper element\n * @returns {String} position\n */\nfunction getPosition(element) {\n  var container = getOffsetParent(element);\n\n  // Decide if the popper will be fixed\n  // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together\n  var isParentFixed = isFixed(container);\n  return isParentFixed ? 'fixed' : 'absolute';\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles - result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {Number} borders - the borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return Number(styles['border' + sideA + 'Width'].split('px')[0]) + Number(styles['border' + sideB + 'Width'].split('px')[0]);\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n    var isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;\n    var rect = void 0;\n\n    // IE10 10 FIX: Please, don't ask, the element isn't\n    // considered in DOM in some circumstances...\n    // This isn't reproducible in IE10 compatibility mode of IE11\n    if (isIE10) {\n        try {\n            rect = element.getBoundingClientRect();\n        } catch (err) {\n            rect = {};\n        }\n    } else {\n        rect = element.getBoundingClientRect();\n    }\n\n    var result = {\n        left: rect.left,\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n    };\n\n    // IE10 FIX: `getBoundingClientRect`, when executed on `documentElement`\n    // will not take in account the `scrollTop` and `scrollLeft`\n    if (element.nodeName === 'HTML' && isIE10) {\n        var _window$document$docu = window.document.documentElement,\n            scrollTop = _window$document$docu.scrollTop,\n            scrollLeft = _window$document$docu.scrollLeft;\n\n        result.top -= scrollTop;\n        result.bottom -= scrollTop;\n        result.left -= scrollLeft;\n        result.right -= scrollLeft;\n    }\n\n    // subtract scrollbar size from sizes\n    var horizScrollbar = rect.width - (element.clientWidth || rect.right - rect.left);\n    var vertScrollbar = rect.height - (element.clientHeight || rect.bottom - rect.top);\n\n    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n    // we make this check conditional for performance reasons\n    if (horizScrollbar || vertScrollbar) {\n        var styles = getStyleComputedProperty(element);\n        horizScrollbar -= getBordersSize(styles, 'x');\n        vertScrollbar -= getBordersSize(styles, 'y');\n    }\n\n    result.right -= horizScrollbar;\n    result.width -= horizScrollbar;\n    result.bottom -= vertScrollbar;\n    result.height -= vertScrollbar;\n\n    return result;\n}\n\nfunction getScroll(element) {\n    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    var nodeName = element.nodeName;\n\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        var html = window.document.documentElement;\n        var scrollingElement = window.document.scrollingElement || html;\n        return scrollingElement[upperSide];\n    }\n\n    return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/**\n * Given an element and one of its parents, return the offset\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @param {HTMLElement} parent\n * @return {Object} rect\n */\nfunction getOffsetRectRelativeToCustomParent(element, parent) {\n    var fixed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var transformed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    var scrollParent = getScrollParent(parent);\n    var elementRect = getBoundingClientRect(element);\n    var parentRect = getBoundingClientRect(parent);\n\n    var rect = {\n        top: elementRect.top - parentRect.top,\n        left: elementRect.left - parentRect.left,\n        bottom: elementRect.top - parentRect.top + elementRect.height,\n        right: elementRect.left - parentRect.left + elementRect.width,\n        width: elementRect.width,\n        height: elementRect.height\n    };\n\n    if (fixed && !transformed) {\n        rect = includeScroll(rect, scrollParent, true);\n    }\n    // When a popper doesn't have any positioned or scrollable parents, `offsetParent.contains(scrollParent)`\n    // will return a \"false positive\". This is happening because `getOffsetParent` returns `html` node,\n    // and `scrollParent` is the `body` node. Hence the additional check.\n    else if (getOffsetParent(element).contains(scrollParent) && scrollParent.nodeName !== 'BODY') {\n            rect = includeScroll(rect, parent);\n        }\n\n    // subtract borderTopWidth and borderTopWidth from final result\n    var styles = getStyleComputedProperty(parent);\n    var borderTopWidth = Number(styles.borderTopWidth.split('px')[0]);\n    var borderLeftWidth = Number(styles.borderLeftWidth.split('px')[0]);\n\n    rect.top -= borderTopWidth;\n    rect.bottom -= borderTopWidth;\n    rect.left -= borderLeftWidth;\n    rect.right -= borderLeftWidth;\n\n    return rect;\n}\n\nfunction getWindowSizes() {\n    var body = window.document.body;\n    var html = window.document.documentElement;\n    return {\n        height: Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight),\n        width: Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth)\n    };\n}\n\n/**\n * Get the position of the given element, relative to its offset parent\n * @method\n * @memberof Popper.Utils\n * @param {Element} element\n * @return {Object} position - Coordinates of the element and its `scrollTop`\n */\nfunction getOffsetRect(element) {\n    var elementRect = void 0;\n    if (element.nodeName === 'HTML') {\n        var _getWindowSizes = getWindowSizes(),\n            width = _getWindowSizes.width,\n            height = _getWindowSizes.height;\n\n        elementRect = {\n            width: width,\n            height: height,\n            left: 0,\n            top: 0\n        };\n    } else {\n        elementRect = {\n            width: element.offsetWidth,\n            height: element.offsetHeight,\n            left: element.offsetLeft,\n            top: element.offsetTop\n        };\n    }\n\n    elementRect.right = elementRect.left + elementRect.width;\n    elementRect.bottom = elementRect.top + elementRect.height;\n\n    // position\n    return elementRect;\n}\n\nfunction getOffsetRectRelativeToViewport(element) {\n    // Offset relative to offsetParent\n    var relativeOffset = getOffsetRect(element);\n\n    if (element.nodeName !== 'HTML') {\n        var offsetParent = getOffsetParent(element);\n        var parentOffset = getOffsetRectRelativeToViewport(offsetParent);\n        var offset = {\n            width: relativeOffset.offsetWidth,\n            height: relativeOffset.offsetHeight,\n            left: relativeOffset.left + parentOffset.left,\n            top: relativeOffset.top + parentOffset.top,\n            right: relativeOffset.right - parentOffset.right,\n            bottom: relativeOffset.bottom - parentOffset.bottom\n        };\n        return offset;\n    }\n\n    return relativeOffset;\n}\n\nfunction getTotalScroll(element) {\n    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n    var scrollParent = getScrollParent(element);\n    var scroll = getScroll(scrollParent, side);\n\n    if (['BODY', 'HTML'].indexOf(scrollParent.nodeName) === -1) {\n        return scroll + getTotalScroll(getParentNode(scrollParent), side);\n    }\n    return scroll;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {Object} data - Object containing the property \"offsets\" generated by `_getOffsets`\n * @param {Number} padding - Boundaries padding\n * @param {Element} boundariesElement - Element used to define the boundaries\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, padding, boundariesElement) {\n    // NOTE: 1 DOM access here\n    var boundaries = { top: 0, left: 0 };\n    var offsetParent = getOffsetParent(popper);\n\n    // Handle viewport case\n    if (boundariesElement === 'viewport') {\n        var _getOffsetRectRelativ = getOffsetRectRelativeToViewport(offsetParent),\n            left = _getOffsetRectRelativ.left,\n            top = _getOffsetRectRelativ.top;\n\n        var _window$document$docu = window.document.documentElement,\n            width = _window$document$docu.clientWidth,\n            height = _window$document$docu.clientHeight;\n\n\n        if (getPosition(popper) === 'fixed') {\n            boundaries.right = width;\n            boundaries.bottom = height;\n        } else {\n            var scrollLeft = getTotalScroll(popper, 'left');\n            var scrollTop = getTotalScroll(popper, 'top');\n\n            boundaries = {\n                top: 0 - top,\n                right: width - left + scrollLeft,\n                bottom: height - top + scrollTop,\n                left: 0 - left\n            };\n        }\n    }\n    // Handle other cases based on DOM element used as boundaries\n    else {\n            var boundariesNode = void 0;\n            if (boundariesElement === 'scrollParent') {\n                boundariesNode = getScrollParent(getParentNode(popper));\n            } else if (boundariesElement === 'window') {\n                boundariesNode = window.document.body;\n            } else {\n                boundariesNode = boundariesElement;\n            }\n\n            // In case of BODY, we need a different computation\n            if (boundariesNode.nodeName === 'BODY') {\n                var _getWindowSizes = getWindowSizes(),\n                    _height = _getWindowSizes.height,\n                    _width = _getWindowSizes.width;\n\n                boundaries.right = _width;\n                boundaries.bottom = _height;\n            }\n            // for all the other DOM elements, this one is good\n            else {\n                    boundaries = getOffsetRectRelativeToCustomParent(boundariesNode, offsetParent, isFixed(popper));\n                }\n        }\n\n    // Add paddings\n    boundaries.left += padding;\n    boundaries.top += padding;\n    boundaries.right -= padding;\n    boundaries.bottom -= padding;\n\n    return boundaries;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper) {\n    if (placement.indexOf('auto') === -1) {\n        return placement;\n    }\n\n    var boundaries = getBoundaries(popper, 0, 'scrollParent');\n\n    var sides = {\n        top: refRect.top - boundaries.top,\n        right: boundaries.right - refRect.right,\n        bottom: boundaries.bottom - refRect.bottom,\n        left: refRect.left - boundaries.left\n    };\n\n    var computedPlacement = Object.keys(sides).sort(function (a, b) {\n        return sides[b] - sides[a];\n    })[0];\n    var variation = placement.split('-')[1];\n\n    return computedPlacement + (variation ? '-' + variation : '');\n}\n\nvar nativeHints = ['native code', '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n];\n\n/**\n * Determine if a function is implemented natively (as opposed to a polyfill).\n * @argument {Function | undefined} fn the function to check\n * @returns {boolean}\n */\nvar isNative = (function (fn) {\n  return nativeHints.some(function (hint) {\n    return (fn || '').toString().indexOf(hint) > -1;\n  });\n});\n\nvar isBrowser = typeof window !== 'undefined';\nvar longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nvar timeoutDuration = 0;\nfor (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n        timeoutDuration = 1;\n        break;\n    }\n}\n\nfunction microtaskDebounce(fn) {\n    var scheduled = false;\n    var i = 0;\n    var elem = document.createElement('span');\n\n    // MutationObserver provides a mechanism for scheduling microtasks, which\n    // are scheduled *before* the next task. This gives us a way to debounce\n    // a function but ensure it's called *before* the next paint.\n    var observer = new MutationObserver(function () {\n        fn();\n        scheduled = false;\n    });\n\n    observer.observe(elem, { attributes: true });\n\n    return function () {\n        if (!scheduled) {\n            scheduled = true;\n            elem.setAttribute('x-index', i);\n            i = i + 1; // don't use compund (+=) because it doesn't get optimized in V8\n        }\n    };\n}\n\nfunction taskDebounce(fn) {\n    var scheduled = false;\n    return function () {\n        if (!scheduled) {\n            scheduled = true;\n            setTimeout(function () {\n                scheduled = false;\n                fn();\n            }, timeoutDuration);\n        }\n    };\n}\n\n// It's common for MutationObserver polyfills to be seen in the wild, however\n// these rely on Mutation Events which only occur when an element is connected\n// to the DOM. The algorithm used in this module does not use a connected element,\n// and so we must ensure that a *native* MutationObserver is available.\nvar supportsNativeMutationObserver = isBrowser && isNative(window.MutationObserver);\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsNativeMutationObserver ? microtaskDebounce : taskDebounce;\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n    // use native find if supported\n    if (Array.prototype.find) {\n        return arr.find(check);\n    }\n\n    // use `filter` to obtain the same behavior of `find`\n    return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n    // use native findIndex if supported\n    if (Array.prototype.findIndex) {\n        return arr.findIndex(function (cur) {\n            return cur[prop] === value;\n        });\n    }\n\n    // use `find` + `indexOf` if `findIndex` isn't supported\n    var match = find(arr, function (obj) {\n        return obj[prop] === value;\n    });\n    return arr.indexOf(match);\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given the popper offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} popperOffsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(popperOffsets) {\n    return _extends({}, popperOffsets, {\n        right: popperOffsets.left + popperOffsets.width,\n        bottom: popperOffsets.top + popperOffsets.height\n    });\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n    var styles = window.getComputedStyle(element);\n    var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n    var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n    var result = {\n        width: element.offsetWidth + y,\n        height: element.offsetHeight + x\n    };\n    return result;\n}\n\n/**\n * Get the opposite placement of the given one/\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(position, popper, referenceOffsets, placement) {\n    placement = placement.split('-')[0];\n\n    // Get popper node sizes\n    var popperRect = getOuterSizes(popper);\n\n    // Add position, width and height to our offsets object\n    var popperOffsets = {\n        position: position,\n        width: popperRect.width,\n        height: popperRect.height\n    };\n\n    // depending by the popper placement we have to compute its offsets slightly differently\n    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    var mainSide = isHoriz ? 'top' : 'left';\n    var secondarySide = isHoriz ? 'left' : 'top';\n    var measurement = isHoriz ? 'height' : 'width';\n    var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n    if (placement === secondarySide) {\n        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n    } else {\n        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n    }\n\n    return popperOffsets;\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var isParentFixed = state.position === 'fixed';\n  var isParentTransformed = state.isParentTransformed;\n  var offsetParent = getOffsetParent(isParentFixed && isParentTransformed ? reference : popper);\n\n  return getOffsetRectRelativeToCustomParent(reference, offsetParent, isParentFixed, isParentTransformed);\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase)\n */\nfunction getSupportedPropertyName(property) {\n    var prefixes = [false, 'ms', 'webkit', 'moz', 'o'];\n    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n    for (var i = 0; i < prefixes.length - 1; i++) {\n        var prefix = prefixes[i];\n        var toCheck = prefix ? '' + prefix + upperProp : property;\n        if (typeof window.document.body.style[toCheck] !== 'undefined') {\n            return toCheck;\n        }\n    }\n    return null;\n}\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {*} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n    return modifiers.some(function (_ref) {\n        var name = _ref.name,\n            enabled = _ref.enabled;\n        return enabled && name === modifierName;\n    });\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n    var requesting = find(modifiers, function (_ref) {\n        var name = _ref.name;\n        return name === requestingName;\n    });\n\n    return !!requesting && modifiers.some(function (modifier) {\n        return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n    });\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Check if the given element has transforms applied to itself or a parent\n * @method\n * @memberof Popper.Utils\n * @param  {Element} element\n * @return {Boolean} answer to \"isTransformed?\"\n */\nfunction isTransformed(element) {\n    if (element.nodeName === 'BODY') {\n        return false;\n    }\n    if (getStyleComputedProperty(element, 'transform') !== 'none') {\n        return true;\n    }\n    return getParentNode(element) ? isTransformed(getParentNode(element)) : element;\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n    // Remove resize event listener on window\n    window.removeEventListener('resize', state.updateBound);\n\n    // Remove scroll event listener on scroll parents\n    state.scrollParents.forEach(function (target) {\n        target.removeEventListener('scroll', state.updateBound);\n    });\n\n    // Reset state\n    state.updateBound = null;\n    state.scrollParents = [];\n    state.scrollElement = null;\n    state.eventsEnabled = false;\n    return state;\n}\n\n/**\n * Loop trough the list of modifiers and run them in order, each of them will then edit the data object\n * @method\n * @memberof Popper.Utils\n * @param {Object} data\n * @param {Array} modifiers\n * @param {Function} ends\n */\nfunction runModifiers(modifiers, data, ends) {\n    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n    modifiersToRun.forEach(function (modifier) {\n        if (modifier.enabled && isFunction(modifier.function)) {\n            data = modifier.function(data, modifier);\n        }\n    });\n\n    return data;\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n    Object.keys(attributes).forEach(function (prop) {\n        var value = attributes[prop];\n        if (value !== false) {\n            element.setAttribute(prop, attributes[prop]);\n        } else {\n            element.removeAttribute(prop);\n        }\n    });\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n    Object.keys(styles).forEach(function (prop) {\n        var unit = '';\n        // add unit if the value is numeric and is one of the following\n        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n            unit = 'px';\n        }\n        element.style[prop] = styles[prop] + unit;\n    });\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n    var isBody = scrollParent.nodeName === 'BODY';\n    var target = isBody ? window : scrollParent;\n    target.addEventListener(event, callback, { passive: true });\n\n    if (!isBody) {\n        attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n    }\n    scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n    // Resize event listener on window\n    state.updateBound = updateBound;\n    window.addEventListener('resize', state.updateBound, { passive: true });\n\n    // Scroll event listener on scroll parents\n    var scrollElement = getScrollParent(reference);\n    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n    state.scrollElement = scrollElement;\n    state.eventsEnabled = true;\n\n    return state;\n}\n\n/** @namespace Popper.Utils */\nvar Utils = {\n    computeAutoPlacement: computeAutoPlacement,\n    debounce: debounce,\n    findIndex: findIndex,\n    getBordersSize: getBordersSize,\n    getBoundaries: getBoundaries,\n    getBoundingClientRect: getBoundingClientRect,\n    getClientRect: getClientRect,\n    getOffsetParent: getOffsetParent,\n    getOffsetRect: getOffsetRect,\n    getOffsetRectRelativeToCustomParent: getOffsetRectRelativeToCustomParent,\n    getOuterSizes: getOuterSizes,\n    getParentNode: getParentNode,\n    getPopperOffsets: getPopperOffsets,\n    getPosition: getPosition,\n    getReferenceOffsets: getReferenceOffsets,\n    getScroll: getScroll,\n    getScrollParent: getScrollParent,\n    getStyleComputedProperty: getStyleComputedProperty,\n    getSupportedPropertyName: getSupportedPropertyName,\n    getTotalScroll: getTotalScroll,\n    getWindowSizes: getWindowSizes,\n    includeScroll: includeScroll,\n    isFixed: isFixed,\n    isFunction: isFunction,\n    isModifierEnabled: isModifierEnabled,\n    isModifierRequired: isModifierRequired,\n    isNative: isNative,\n    isNumeric: isNumeric,\n    isTransformed: isTransformed,\n    removeEventListeners: removeEventListeners,\n    runModifiers: runModifiers,\n    setAttributes: setAttributes,\n    setStyles: setStyles,\n    setupEventListeners: setupEventListeners\n};\n\n/**\n * Apply the computed styles to the popper element\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data, options) {\n    // apply the final offsets to the popper\n    // NOTE: 1 DOM access here\n    var styles = {\n        position: data.offsets.popper.position\n    };\n\n    var attributes = {\n        'x-placement': data.placement\n    };\n\n    // round top and left to avoid blurry text\n    var left = Math.round(data.offsets.popper.left);\n    var top = Math.round(data.offsets.popper.top);\n\n    // if gpuAcceleration is set to true and transform is supported,\n    //  we use `translate3d` to apply the position to the popper we\n    // automatically use the supported prefixed version if needed\n    var prefixedProperty = getSupportedPropertyName('transform');\n    if (options.gpuAcceleration && prefixedProperty) {\n        styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n        styles.top = 0;\n        styles.left = 0;\n        styles.willChange = 'transform';\n    }\n    // othwerise, we use the standard `left` and `top` properties\n    else {\n            styles.left = left;\n            styles.top = top;\n            styles.willChange = 'top, left';\n        }\n\n    // any property present in `data.styles` will be applied to the popper,\n    // in this way we can make the 3rd party modifiers add custom styles to it\n    // Be aware, modifiers could override the properties defined in the previous\n    // lines of this modifier!\n    setStyles(data.instance.popper, _extends({}, styles, data.styles));\n\n    // any property present in `data.attributes` will be applied to the popper,\n    // they will be set as HTML attributes of the element\n    setAttributes(data.instance.popper, _extends({}, attributes, data.attributes));\n\n    // if the arrow style has been computed, apply the arrow style\n    if (data.offsets.arrow) {\n        setStyles(data.arrowElement, data.offsets.arrow);\n    }\n\n    return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used to add margins to the popper\n * margins needs to be calculated to get the correct popper offsets\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper.\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n    // compute reference element offsets\n    var referenceOffsets = getReferenceOffsets(state, popper, reference);\n\n    // compute auto placement, store placement inside the data object,\n    // modifiers will be able to edit `placement` if needed\n    // and refer to originalPlacement to know the original value\n    options.placement = computeAutoPlacement(options.placement, referenceOffsets, popper);\n\n    popper.setAttribute('x-placement', options.placement);\n    return options;\n}\n\n/**\n * Modifier used to move the arrowElements on the edge of the popper to make sure them are always between the popper and the reference element\n * It will use the CSS outer size of the arrowElement element to know how many pixels of conjuction are needed\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n    // arrow depends on keepTogether in order to work\n    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n        console.warn('WARNING: `keepTogether` modifier is required by arrow modifier in order to work, be sure to include it before `arrow`!');\n        return data;\n    }\n\n    var arrowElement = options.element;\n\n    // if arrowElement is a string, suppose it's a CSS selector\n    if (typeof arrowElement === 'string') {\n        arrowElement = data.instance.popper.querySelector(arrowElement);\n\n        // if arrowElement is not found, don't run the modifier\n        if (!arrowElement) {\n            return data;\n        }\n    } else {\n        // if the arrowElement isn't a query selector we must check that the\n        // provided DOM node is child of its popper node\n        if (!data.instance.popper.contains(arrowElement)) {\n            console.warn('WARNING: `arrow.element` must be child of its popper element!');\n            return data;\n        }\n    }\n\n    var placement = data.placement.split('-')[0];\n    var popper = getClientRect(data.offsets.popper);\n    var reference = data.offsets.reference;\n    var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n    var len = isVertical ? 'height' : 'width';\n    var side = isVertical ? 'top' : 'left';\n    var altSide = isVertical ? 'left' : 'top';\n    var opSide = isVertical ? 'bottom' : 'right';\n    var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n    //\n    // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction\n    //\n\n    // top/left side\n    if (reference[opSide] - arrowElementSize < popper[side]) {\n        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n    }\n    // bottom/right side\n    if (reference[side] + arrowElementSize > popper[opSide]) {\n        data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n    }\n\n    // compute center of the popper\n    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n    // Compute the sideValue using the updated popper offsets\n    var sideValue = center - getClientRect(data.offsets.popper)[side];\n\n    // prevent arrowElement from being placed not contiguously to its popper\n    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n    data.arrowElement = arrowElement;\n    data.offsets.arrow = {};\n    data.offsets.arrow[side] = sideValue;\n    data.offsets.arrow[altSide] = ''; // make sure to unset any eventual altSide value from the DOM node\n\n    return data;\n}\n\n/**\n * Get the opposite placement variation of the given one/\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n    if (variation === 'end') {\n        return 'start';\n    } else if (variation === 'start') {\n        return 'end';\n    }\n    return variation;\n}\n\n/**\n * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.\n * Requires the `preventOverflow` modifier before it in order to work.\n * **NOTE:** data.instance modifier will run all its previous modifiers everytime it tries to flip the popper!\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n    // if `inner` modifier is enabled, we can't use the `flip` modifier\n    if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n        return data;\n    }\n\n    if (data.flipped && data.placement === data.originalPlacement) {\n        // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n        return data;\n    }\n\n    var boundaries = getBoundaries(data.instance.popper, options.padding, options.boundariesElement);\n\n    var placement = data.placement.split('-')[0];\n    var placementOpposite = getOppositePlacement(placement);\n    var variation = data.placement.split('-')[1] || '';\n\n    var flipOrder = [];\n\n    if (options.behavior === 'flip') {\n        flipOrder = [placement, placementOpposite];\n    } else {\n        flipOrder = options.behavior;\n    }\n\n    flipOrder.forEach(function (step, index) {\n        if (placement !== step || flipOrder.length === index + 1) {\n            return data;\n        }\n\n        placement = data.placement.split('-')[0];\n        placementOpposite = getOppositePlacement(placement);\n\n        var popperOffsets = getClientRect(data.offsets.popper);\n        var refOffsets = data.offsets.reference;\n\n        // using floor because the reference offsets may contain decimals we are not going to consider here\n        var floor = Math.floor;\n        var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n        var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n        var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n        var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n        var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n        var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n        // flip the variation if required\n        var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n        var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n        if (overlapsRef || overflowsBoundaries || flippedVariation) {\n            // this boolean to detect any flip loop\n            data.flipped = true;\n\n            if (overlapsRef || overflowsBoundaries) {\n                placement = flipOrder[index + 1];\n            }\n\n            if (flippedVariation) {\n                variation = getOppositeVariation(variation);\n            }\n\n            data.placement = placement + (variation ? '-' + variation : '');\n            data.offsets.popper = getPopperOffsets(data.instance.state.position, data.instance.popper, data.offsets.reference, data.placement);\n\n            data = runModifiers(data.instance.modifiers, data, 'flip');\n        }\n    });\n    return data;\n}\n\n/**\n * Modifier used to make sure the popper is always near its reference element\n * It cares only about the first axis, you can still have poppers with margin\n * between the popper and its reference element.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n    var popper = getClientRect(data.offsets.popper);\n    var reference = data.offsets.reference;\n    var placement = data.placement.split('-')[0];\n    var floor = Math.floor;\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    var side = isVertical ? 'right' : 'bottom';\n    var opSide = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    if (popper[side] < floor(reference[opSide])) {\n        data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n    }\n    if (popper[opSide] > floor(reference[side])) {\n        data.offsets.popper[opSide] = floor(reference[side]);\n    }\n\n    return data;\n}\n\n/**\n * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.\n * The offsets will shift the popper on the side of its reference element.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n *      Basic usage allows a number used to nudge the popper by the given amount of pixels.\n *      You can pass a percentage value as string (eg. `20%`) to nudge by the given percentage (relative to reference element size)\n *      Other supported units are `vh` and `vw` (relative to viewport)\n *      Additionally, you can pass a pair of values (eg. `10 20` or `2vh 20%`) to nudge the popper\n *      on both axis.\n *      A note about percentage values, if you want to refer a percentage to the popper size instead of the reference element size,\n *      use `%p` instead of `%` (eg: `20%p`). To make it clearer, you can replace `%` with `%r` and use eg.`10%p 25%r`.\n *      > **Heads up!** The order of the axis is relative to the popper placement: `bottom` or `top` are `X,Y`, the other are `Y,X`\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, options) {\n    var placement = data.placement;\n    var popper = data.offsets.popper;\n\n    var offsets = void 0;\n    if (isNumeric(options.offset)) {\n        offsets = [options.offset, 0];\n    } else {\n        // split the offset in case we are providing a pair of offsets separated\n        // by a blank space\n        offsets = options.offset.split(' ');\n\n        // itherate through each offset to compute them in case they are percentages\n        offsets = offsets.map(function (offset, index) {\n            // separate value from unit\n            var split = offset.match(/(\\d*\\.?\\d*)(.*)/);\n            var value = +split[1];\n            var unit = split[2];\n\n            // use height if placement is left or right and index is 0 otherwise use width\n            // in this way the first offset will use an axis and the second one\n            // will use the other one\n            var useHeight = placement.indexOf('right') !== -1 || placement.indexOf('left') !== -1;\n\n            if (index === 1) {\n                useHeight = !useHeight;\n            }\n\n            var measurement = useHeight ? 'height' : 'width';\n\n            // if is a percentage relative to the popper (%p), we calculate the value of it using\n            // as base the sizes of the popper\n            // if is a percentage (% or %r), we calculate the value of it using as base the\n            // sizes of the reference element\n            if (unit.indexOf('%') === 0) {\n                var element = void 0;\n                switch (unit) {\n                    case '%p':\n                        element = data.offsets.popper;\n                        break;\n                    case '%':\n                    case '$r':\n                    default:\n                        element = data.offsets.reference;\n                }\n\n                var rect = getClientRect(element);\n                var len = rect[measurement];\n                return len / 100 * value;\n            }\n            // if is a vh or vw, we calculate the size based on the viewport\n            else if (unit === 'vh' || unit === 'vw') {\n                    var size = void 0;\n                    if (unit === 'vh') {\n                        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n                    } else {\n                        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n                    }\n                    return size / 100 * value;\n                }\n                // if is an explicit pixel unit, we get rid of the unit and keep the value\n                else if (unit === 'px') {\n                        return +value;\n                    }\n                    // if is an implicit unit, it's px, and we return just the value\n                    else {\n                            return +offset;\n                        }\n        });\n    }\n\n    if (data.placement.indexOf('left') !== -1) {\n        popper.top += offsets[0];\n        popper.left -= offsets[1] || 0;\n    } else if (data.placement.indexOf('right') !== -1) {\n        popper.top += offsets[0];\n        popper.left += offsets[1] || 0;\n    } else if (data.placement.indexOf('top') !== -1) {\n        popper.left += offsets[0];\n        popper.top -= offsets[1] || 0;\n    } else if (data.placement.indexOf('bottom') !== -1) {\n        popper.left += offsets[0];\n        popper.top += offsets[1] || 0;\n    }\n    return data;\n}\n\n/**\n * Modifier used to prevent the popper from being positioned outside the boundary.\n *\n * An scenario exists where the reference itself is not within the boundaries. We can\n * say it has \"escaped the boundaries\" — or just \"escaped\". In this case we need to\n * decide whether the popper should either:\n *\n * - detach from the reference and remain \"trapped\" in the boundaries, or\n * - if it should be ignore the boundary and \"escape with the reference\"\n *\n * When `escapeWithReference` is `true`, and reference is completely outside the\n * boundaries, the popper will overflow (or completely leave) the boundaries in order\n * to remain attached to the edge of the reference.\n *\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n    var boundaries = getBoundaries(data.instance.popper, options.padding, boundariesElement);\n    options.boundaries = boundaries;\n\n    var order = options.priority;\n    var popper = getClientRect(data.offsets.popper);\n\n    var check = {\n        primary: function primary(placement) {\n            var value = popper[placement];\n            if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n                value = Math.max(popper[placement], boundaries[placement]);\n            }\n            return defineProperty({}, placement, value);\n        },\n        secondary: function secondary(placement) {\n            var mainSide = placement === 'right' ? 'left' : 'top';\n            var value = popper[mainSide];\n            if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n                value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n            }\n            return defineProperty({}, mainSide, value);\n        }\n    };\n\n    order.forEach(function (placement) {\n        var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n        popper = _extends({}, popper, check[side](placement));\n    });\n\n    data.offsets.popper = popper;\n\n    return data;\n}\n\n/**\n * Modifier used to shift the popper on the start or end of its reference element side\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n    var placement = data.placement;\n    var basePlacement = placement.split('-')[0];\n    var shiftvariation = placement.split('-')[1];\n\n    // if shift shiftvariation is specified, run the modifier\n    if (shiftvariation) {\n        var reference = data.offsets.reference;\n        var popper = getClientRect(data.offsets.popper);\n        var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n        var side = isVertical ? 'left' : 'top';\n        var measurement = isVertical ? 'width' : 'height';\n\n        var shiftOffsets = {\n            start: defineProperty({}, side, reference[side]),\n            end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n        };\n\n        data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n    }\n\n    return data;\n}\n\n/**\n * Modifier used to hide the popper when its reference element is outside of the\n * popper boundaries. It will set an x-hidden attribute which can be used to hide\n * the popper when its reference is out of boundaries.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n        console.warn('WARNING: preventOverflow modifier is required by hide modifier in order to work, be sure to include it before hide!');\n        return data;\n    }\n\n    var refRect = data.offsets.reference;\n    var bound = find(data.instance.modifiers, function (modifier) {\n        return modifier.name === 'preventOverflow';\n    }).boundaries;\n\n    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n        // Avoid unnecessary DOM access if visibility hasn't changed\n        if (data.hide === true) {\n            return data;\n        }\n\n        data.hide = true;\n        data.attributes['x-out-of-boundaries'] = '';\n    } else {\n        // Avoid unnecessary DOM access if visibility hasn't changed\n        if (data.hide === false) {\n            return data;\n        }\n\n        data.hide = false;\n        data.attributes['x-out-of-boundaries'] = false;\n    }\n\n    return data;\n}\n\n/**\n * Modifier used to make the popper flow toward the inner of the reference element.\n * By default, when this modifier is disabled, the popper will be placed outside\n * the reference element.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n    var placement = data.placement;\n    var basePlacement = placement.split('-')[0];\n    var popper = getClientRect(data.offsets.popper);\n    var reference = getClientRect(data.offsets.reference);\n    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n    popper[isHoriz ? 'left' : 'top'] = reference[placement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n    data.placement = getOppositePlacement(placement);\n    data.offsets.popper = getClientRect(popper);\n\n    return data;\n}\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.\n * Popper.js uses a set of 7 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Each modifier is an object containing several properties listed below.\n * @namespace Modifiers\n * @param {Object} modifier - Modifier descriptor\n * @param {Integer} modifier.order\n *      The `order` property defines the execution order of the modifiers.\n *      The built-in modifiers have orders with a gap of 100 units in between,\n *      this allows you to inject additional modifiers between the existing ones\n *      without having to redefine the order of all of them.\n *      The modifiers are executed starting from the one with the lowest order.\n * @param {Boolean} modifier.enabled - When `true`, the modifier will be used.\n * @param {Modifiers~modifier} modifier.function - Modifier function.\n * @param {Modifiers~onLoad} modifier.onLoad - Function executed on popper initalization\n * @return {Object} data - Each modifier must return the modified `data` object.\n */\nvar modifiers = {\n  shift: {\n    order: 100,\n    enabled: true,\n    function: shift\n  },\n  offset: {\n    order: 200,\n    enabled: true,\n    function: offset,\n    // nudges popper from its origin by the given amount of pixels (can be negative)\n    offset: 0\n  },\n  preventOverflow: {\n    order: 300,\n    enabled: true,\n    function: preventOverflow,\n    // popper will try to prevent overflow following these priorities\n    //  by default, then, it could overflow on the left and on top of the boundariesElement\n    priority: ['left', 'right', 'top', 'bottom'],\n    // amount of pixel used to define a minimum distance between the boundaries and the popper\n    // this makes sure the popper has always a little padding between the edges of its container\n    padding: 5,\n    boundariesElement: 'scrollParent'\n  },\n  keepTogether: {\n    order: 400,\n    enabled: true,\n    function: keepTogether\n  },\n  arrow: {\n    order: 500,\n    enabled: true,\n    function: arrow,\n    // selector or node used as arrow\n    element: '[x-arrow]'\n  },\n  flip: {\n    order: 600,\n    enabled: true,\n    function: flip,\n    // the behavior used to change the popper's placement\n    behavior: 'flip',\n    // the popper will flip if it hits the edges of the boundariesElement - padding\n    padding: 5,\n    boundariesElement: 'viewport'\n  },\n  inner: {\n    order: 700,\n    enabled: false,\n    function: inner\n  },\n  hide: {\n    order: 800,\n    enabled: true,\n    function: hide\n  },\n  applyStyle: {\n    order: 900,\n    enabled: true,\n    // if true, it uses the CSS 3d transformation to position the popper\n    gpuAcceleration: true,\n    function: applyStyle,\n    onLoad: applyStyleOnLoad\n  }\n};\n\n/**\n * Modifiers can edit the `data` object to change the beheavior of the popper.\n * This object contains all the informations used by Popper.js to compute the\n * popper position.\n * The modifier can edit the data as needed, and then `return` it as result.\n *\n * @callback Modifiers~modifier\n * @param {dataObject} data\n * @return {dataObject} modified data\n */\n\n/**\n * The `dataObject` is an object containing all the informations used by Popper.js\n * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements.\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arro] `top` and `left` offsets, only one of them will be different from 0\n */\n\n// Utils\n// Modifiers\n// default options\nvar DEFAULTS = {\n    // placement of the popper\n    placement: 'bottom',\n\n    // whether events (resize, scroll) are initially enabled\n    eventsEnabled: true,\n\n    /**\n     * Callback called when the popper is created.\n     * By default, is set to no-op.\n     * Access Popper.js instance with `data.instance`.\n     * @callback createCallback\n     * @static\n     * @param {dataObject} data\n     */\n    onCreate: function onCreate() {},\n\n    /**\n     * Callback called when the popper is updated, this callback is not called\n     * on the initialization/creation of the popper, but only on subsequent\n     * updates.\n     * By default, is set to no-op.\n     * Access Popper.js instance with `data.instance`.\n     * @callback updateCallback\n     * @static\n     * @param {dataObject} data\n     */\n    onUpdate: function onUpdate() {},\n\n    // list of functions used to modify the offsets before they are applied to the popper\n    modifiers: modifiers\n};\n\n/**\n * Create a new Popper.js instance\n * @class Popper\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper.\n * @param {Object} options\n * @param {String} options.placement=bottom\n *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),\n *      left(-start, -end)`\n *\n * @param {Boolean} options.eventsEnabled=true\n *      Whether events (resize, scroll) are initially enabled\n * @param {Boolean} options.gpuAcceleration=true\n *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the\n *      browser to use the GPU to accelerate the rendering.\n *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.\n *\n * @param {Boolean} options.removeOnDestroy=false\n *      Set to true if you want to automatically remove the popper when you call the `destroy` method.\n *\n * @param {Object} options.modifiers\n *      List of functions used to modify the data before they are applied to the popper (see source code for default values)\n *\n * @param {Object} options.modifiers.arrow - Arrow modifier configuration\n * @param {String|HTMLElement} options.modifiers.arrow.element='[x-arrow]'\n *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of\n *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its\n *      reference element.\n *      By default, it will look for a child node of the popper with the `x-arrow` attribute.\n *\n * @param {Object} options.modifiers.offset - Offset modifier configuration\n * @param {Number} options.modifiers.offset.offset=0\n *      Amount of pixels the popper will be shifted (can be negative).\n *\n * @param {Object} options.modifiers.preventOverflow - PreventOverflow modifier configuration\n * @param {Array} [options.modifiers.preventOverflow.priority=['left', 'right', 'top', 'bottom']]\n *      Priority used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,\n *      this means that the last one will never overflow\n * @param {String|HTMLElement} options.modifiers.preventOverflow.boundariesElement='scrollParent'\n *      Boundaries used by the modifier, can be `scrollParent`, `window`, `viewport` or any DOM element.\n * @param {Number} options.modifiers.preventOverflow.padding=5\n *      Amount of pixel used to define a minimum distance between the boundaries and the popper\n *      this makes sure the popper has always a little padding between the edges of its container.\n *\n * @param {Object} options.modifiers.flip - Flip modifier configuration\n * @param {String|Array} options.modifiers.flip.behavior='flip'\n *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to\n *      overlap its reference element. Defining `flip` as value, the placement will be flipped on\n *      its axis (`right - left`, `top - bottom`).\n *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify\n *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,\n *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)\n * @param {String|HTMLElement} options.modifiers.flip.boundariesElement='viewport'\n *      The element which will define the boundaries of the popper position, the popper will never be placed outside\n *      of the defined boundaries (except if `keepTogether` is enabled)\n *\n * @param {Object} options.modifiers.inner - Inner modifier configuration\n * @param {Number} options.modifiers.inner.enabled=false\n *      Set to `true` to make the popper flow toward the inner of the reference element.\n *\n * @param {Number} options.modifiers.flip.padding=5\n *      Amount of pixel used to define a minimum distance between the boundaries and the popper\n *      this makes sure the popper has always a little padding between the edges of its container.\n *\n * @param {createCallback} options.onCreate - onCreate callback\n *      Function called after the Popper has been instantiated.\n *\n * @param {updateCallback} options.onUpdate - onUpdate callback\n *      Function called on subsequent updates of Popper.\n *\n * @return {Object} instance - The generated Popper.js instance\n */\n\nvar Popper = function () {\n    function Popper(reference, popper) {\n        var _this = this;\n\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        classCallCheck(this, Popper);\n\n        this.scheduleUpdate = function () {\n            return requestAnimationFrame(_this.update);\n        };\n\n        // make update() debounced, so that it only runs at most once-per-tick\n        this.update = debounce(this.update.bind(this));\n\n        // with {} we create a new object with the options inside it\n        this.options = _extends({}, Popper.Defaults, options);\n\n        // init state\n        this.state = {\n            isDestroyed: false,\n            isCreated: false,\n            scrollParents: []\n        };\n\n        // get reference and popper elements (allow jQuery wrappers)\n        this.reference = reference.jquery ? reference[0] : reference;\n        this.popper = popper.jquery ? popper[0] : popper;\n\n        // refactoring modifiers' list (Object => Array)\n        this.modifiers = Object.keys(Popper.Defaults.modifiers).map(function (name) {\n            return _extends({ name: name }, Popper.Defaults.modifiers[name]);\n        });\n\n        // assign default values to modifiers, making sure to override them with\n        // the ones defined by user\n        this.modifiers = this.modifiers.map(function (defaultConfig) {\n            var userConfig = options.modifiers && options.modifiers[defaultConfig.name] || {};\n            return _extends({}, defaultConfig, userConfig);\n        });\n\n        // add custom modifiers to the modifiers list\n        if (options.modifiers) {\n            this.options.modifiers = _extends({}, Popper.Defaults.modifiers, options.modifiers);\n            Object.keys(options.modifiers).forEach(function (name) {\n                // take in account only custom modifiers\n                if (Popper.Defaults.modifiers[name] === undefined) {\n                    var modifier = options.modifiers[name];\n                    modifier.name = name;\n                    _this.modifiers.push(modifier);\n                }\n            });\n        }\n\n        // get the popper position type\n        this.state.position = getPosition(this.reference);\n\n        // sort the modifiers by order\n        this.modifiers = this.modifiers.sort(function (a, b) {\n            return a.order - b.order;\n        });\n\n        // modifiers have the ability to execute arbitrary code when Popper.js get inited\n        // such code is executed in the same order of its modifier\n        // they could add new properties to their options configuration\n        // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n        this.modifiers.forEach(function (modifierOptions) {\n            if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n                modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n            }\n        });\n\n        // determine how we should set the origin of offsets\n        this.state.isParentTransformed = isTransformed(this.popper.parentNode);\n\n        // fire the first update to position the popper in the right place\n        this.update();\n\n        var eventsEnabled = this.options.eventsEnabled;\n        if (eventsEnabled) {\n            // setup event listeners, they will take care of update the position in specific situations\n            this.enableEventListeners();\n        }\n\n        this.state.eventsEnabled = eventsEnabled;\n    }\n\n    //\n    // Methods\n    //\n\n    /**\n     * Updates the position of the popper, computing the new offsets and applying the new style\n     * Prefer `scheduleUpdate` over `update` because of performance reasons\n     * @method\n     * @memberof Popper\n     */\n\n\n    createClass(Popper, [{\n        key: 'update',\n        value: function update() {\n            // if popper is destroyed, don't perform any further update\n            if (this.state.isDestroyed) {\n                return;\n            }\n\n            var data = {\n                instance: this,\n                styles: {},\n                attributes: {},\n                flipped: false,\n                offsets: {}\n            };\n\n            // make sure to apply the popper position before any computation\n            this.state.position = getPosition(this.reference);\n            setStyles(this.popper, { position: this.state.position });\n\n            // compute reference element offsets\n            data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);\n\n            // compute auto placement, store placement inside the data object,\n            // modifiers will be able to edit `placement` if needed\n            // and refer to originalPlacement to know the original value\n            data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper);\n\n            // store the computed placement inside `originalPlacement`\n            data.originalPlacement = this.options.placement;\n\n            // compute the popper offsets\n            data.offsets.popper = getPopperOffsets(this.state, this.popper, data.offsets.reference, data.placement);\n\n            // run the modifiers\n            data = runModifiers(this.modifiers, data);\n\n            // the first `update` will call `onCreate` callback\n            // the other ones will call `onUpdate` callback\n            if (!this.state.isCreated) {\n                this.state.isCreated = true;\n                this.options.onCreate(data);\n            } else {\n                this.options.onUpdate(data);\n            }\n        }\n\n        /**\n         * Schedule an update, it will run on the next UI update available\n         * @method scheduleUpdate\n         * @memberof Popper\n         */\n\n    }, {\n        key: 'destroy',\n\n\n        /**\n         * Destroy the popper\n         * @method\n         * @memberof Popper\n         */\n        value: function destroy() {\n            this.state.isDestroyed = true;\n\n            // touch DOM only if `applyStyle` modifier is enabled\n            if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n                this.popper.removeAttribute('x-placement');\n                this.popper.style.left = '';\n                this.popper.style.position = '';\n                this.popper.style.top = '';\n                this.popper.style[getSupportedPropertyName('transform')] = '';\n            }\n\n            this.disableEventListeners();\n\n            // remove the popper if user explicity asked for the deletion on destroy\n            // do not use `remove` because IE11 doesn't support it\n            if (this.options.removeOnDestroy) {\n                this.popper.parentNode.removeChild(this.popper);\n            }\n            return this;\n        }\n\n        /**\n         * it will add resize/scroll events and start recalculating\n         * position of the popper element when they are triggered\n         * @method\n         * @memberof Popper\n         */\n\n    }, {\n        key: 'enableEventListeners',\n        value: function enableEventListeners() {\n            if (!this.state.eventsEnabled) {\n                this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n            }\n        }\n\n        /**\n         * it will remove resize/scroll events and won't recalculate\n         * popper position when they are triggered. It also won't trigger onUpdate callback anymore,\n         * unless you call 'update' method manually.\n         * @method\n         * @memberof Popper\n         */\n\n    }, {\n        key: 'disableEventListeners',\n        value: function disableEventListeners() {\n            if (this.state.eventsEnabled) {\n                window.cancelAnimationFrame(this.scheduleUpdate);\n                this.state = removeEventListeners(this.reference, this.state);\n            }\n        }\n\n        /**\n         * Collection of utilities useful when writing custom modifiers\n         * @memberof Popper\n         */\n\n\n        /**\n         * List of accepted placements to use as values of the `placement` option\n         * @memberof Popper\n         */\n\n\n        /**\n         * Default Popper.js options\n         * @memberof Popper\n         */\n\n    }]);\n    return Popper;\n}();\n\nPopper.Utils = Utils;\nPopper.placements = ['auto', 'auto-start', 'auto-end', 'top', 'top-start', 'top-end', 'right', 'right-start', 'right-end', 'bottom', 'bottom-start', 'bottom-end', 'left', 'left-start', 'left-end'];\nPopper.Defaults = DEFAULTS;\n\nreturn Popper;\n\n})));\n//# sourceMappingURL=popper.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/popper.js/dist/popper.es5.js\n// module id = 3\n// module chunks = 0","\n/* styles */\nrequire(\"!!../node_modules/vue-cli/node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?-autoprefixer&sourceMap!../node_modules/vue-loader/lib/style-rewriter?id=data-v-5fc95a8e!postcss-loader?sourceMap!less-loader?sourceMap!../node_modules/vue-loader/lib/selector?type=styles&index=0!./Tooltip.vue\")\n\nvar Component = require(\"!../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./Tooltip.vue\"),\n  /* template */\n  null,\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Tooltip.vue\n// module id = 5\n// module chunks = 0","module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/component-normalizer.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}